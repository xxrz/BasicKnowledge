# JAVA

## 面向对象

### 面向对象和面向过程的特点和区别？

面向对象：先确定对象的结构，再确定数据结构的算法，适合大规模的问题。

面向过程：以过程为中心的编程思想，分析解决问题所需要的步骤，按照步骤进行编程。无需类调用的实例化，所以性能比面向对象高，开销较小



面向过程的特点：封装、继承、多态

-   封装：将数据和行为组合在一个包里，并对对象的使用者隐藏具体的实现方式。一个类不能直接调用其他类的实例变量。（把对象的属性隐藏在内部，不允许外部对象直接访问对象内部信息）
-   继承：将一类事物的共有属性和行为抽象成一个父类，而每一个子类可以继承这些父类的属性和方法，还可以扩展自己特有的行为和属性，提高了代码的复用性。
-   多态：**一个对象变量可以指向多种实际类型的现象叫多态**。多态是为了实现接口重用，多态的一大作用就是解耦，允许父类引用或接口指向子类对象。多态的表现形式有重写（运行时多态：动态绑定）和重载（编译时多态）。通俗的说：某个行为（方法），不同的对象去完成时产生不同的状态。



### 多态

通俗的说：某个行为（方法），不同的对象去完成时产生不同的状态。

eg：行为：买车票。普通人全价，学生半价，军人优先。

**一个对象变量可以指向多种实际类型的现象叫多态**。多态是为了实现接口重用，多态的一大作用就是解耦，允许父类引用或接口指向子类对象。多态的表现形式有重写（运行时多态：动态绑定）和重载（编译时多态）。



### 接口和继承的区别

共同点：

都实现了多态

都不能被实例化

都可以有默认实现的方法



区别：

抽象类不能多继承，接口可以多实现

接口必须是public，继承没有这个限制

接口的返回值必须是staitc final，继承没有这个限制

多个不相关的类可以实现接口，多个相关的类使用继承，接口强调行为，抽象类强调代码复用

抽象类需要满足**里式替换原则**，即任何基类可以出现的地方，子类一定可以出代替。



### 重写和重载的区别？重载的返回值必须一定吗？重写是对于同一个类吗？

重写和重载都实现了多态，其中：

重写（override）：方法名，参数列表，返回类型相同，仅对方法体进行修改和重写，访问修饰符的限制不能少于父类的。为了满足里式替换原则，重写有以下三个限制：

- 子类方法的**访问权限**必须大于等于父类方法；
- 子类方法的**返回类型**必须是父类方法返回类型或为其子类型。
- 子类方法抛出的**异常类型**必须是父类抛出异常类型或为其子类型。

使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

重载（overload）：方法名相同，但参数列表中的类型，顺序，个数至少有一个不同，返回值可以相同可以不同，但光返回值不同，其他相同则不算重载。



### 方法调用

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)



### new一个类对象中各部分执行顺序（构造器的具体处理步骤）

new一个类对象类中各部分执行顺序：静态代码块 -> 非静态代码块 -> 构造函数 -> 一般方法。

子类继承父类各部分执行顺序为：

父静态代码块（初始化块） -> 子静态代码块 ->父非静态代码 （初始化块）-> 父无参构造函数 -> 子静态代码块 -> 子构造函数 -> 方法。



## JAVA基础

### int和Integer区别，都需要实例化再使用吗？

int不用，int是基本类型

Integer是int的包装类，需要实例化再使用。

基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。



### ==和equals

对于**基本类型**来说，== 比较的是**值**是否相等；

对于**引用类型**来说，== 比较的是两个**引用**是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；

对于引用类型（包括包装类型）来说，**equals** 如果没有被重写，对比它们的**地址**是否相等；如果 equals()方法被**重写**（例如 String），则比较的是地址里的**内容**。



### static和final是什么，区别？

**final** 

final类不能被继承，没有子类，final类中的方法默认是final的

final方法不能被子类的方法复盖，但可以被继承

final成员变量表示常量，只能被赋值一次，赋值后不能再被改变

final不能用于修饰构造方法（构造器不是通过继承得到的，所以没有必要把它声明为final的）

private不能被子类方法覆盖，private类型的方法默认是final类型的 

final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。

注意：final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。



**static**

static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。 

被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象，不生成static变量的副本，而是类的所有实例共享同一个static变量。 

-   类成员变量
-   静态变量（类变量）: static修饰
-   实例变量    : 无static修饰
-   局部变量



**static和final一起使用**

static final用来修饰成员变量和成员方法，可以理解为“全局变量”

对于变量，表示一旦给值就不可修改，并且通过类名可以访问。

对于方法，表示不可覆盖，并且可以通过类名直接访问。

注意：

对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。

 

### 内存溢出和内存泄漏？场景？如何规避？

**内存溢出**

out of memory指程序要求的内存超出了系统所能分配的范围，出现out of memory；比如申请一个int类型，但给了它一个int才能存放的数，就会出现内存溢出，或者是创建一个大的对象，而堆内存放不下这个对象，这也是内存溢出。

**内存泄漏**

memory leak是指程序在申请内存后，无法释放已申请的内存空间(指分配出去的内存无法被gc回收)。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

因此，内存泄露可能会导致内存溢出。内存溢出会抛出异常，内存泄露不会抛出异常，大多数时候程序看起来是正常运行的。

**规避**

-   尽早释放无用对象的引用 
    好的办法是使用临时变量的时候，让引用变量在推出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄漏。
-   程序进行字符串处理时，尽量避免使用String，而应该使用StringBuffer。 
    因为String类是不可变的，每一个String对象都会独立占用内存一块区域。
-   尽量少用静态变量 
    因为静态变量是全局的，存在方法区，GC不会回收。（用永久代实现的方法区，垃圾回收行为在这个区域是比较少出现的，垃圾回收器的主要目标是针对常量池和类型的卸载）
-   尽量运用对象池技术以提高系统性能 
    生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。
-   不要在经常调用的方法中创建对象，尤其忌讳在循环中创建对象 
    可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取这些对象，而不用每次new之后又丢弃。



### equals和hashcode

**作用**

hashcode是为了提高查找元素的效率。如果想判断一个元素特别多的set中是否存在某个值，那么可以先对值求hashcode，再从相同hashcode的值中进行equals比较，比较是否有这个值存在。避免对所有值进行equals的比较。

Object：

```java
public native int hashCode();

public boolean equals(Object obj) {
    return (this == obj);
}
```

String:

R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：`31*x == (x<<5)-x`，编译器会自动进行这个优化。

```java
public int hashCode() {
    int h = hash;
    //hash的初始值为0
    if (h == 0 && value.length > 0) {
        // 字符串数组化
        char val[] = value;
        // 以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    //如果有hash则直接返回了
    return h;
}

public boolean equals(Object anObject) {
    // ==比较两个对象的地址是不是一致，如果一致说明是引用同一个对象直接返回true
    if (this == anObject) {
        return true;
    }
    // 先判断对象是不是String类的实例，然后比较字符串中的内容，如果一致返回true，如果不一致返回false。
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```



**同时重写的问题**

等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。

Object里面的equals一般默认表示，两个引用是否指向内存的同一的对象（**地址值**），而我们一般想比较的是**值**是否相等

Object里面的hashCode，一般是通过**地址值**生成的

所以一定要一起重写



## 数据结构



### 数组和链表

**数组：**

-   内存连续

-   数组支持随机访问，但插入删除的代价很高，需要移动大量元素；



**链表：**

-   内存不连续

- 链表不支持随机访问，但插入删除只需要改变指针。

    

### 栈和队列

**栈：（stack）**

先进后出

LinkedList : 

Stack：push入栈，pop出栈



**队列：(queue)**

先进先出

LinkedList :  offer入队列, poll出队列



### LinkedList和ArrayList？以及底层结构

1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）
3. 插入和删除是否受元素位置的影响：
    - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
    - `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。
4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
5. **内存空间占用：** `ArrayList` 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放**直接后继和直接前驱以及数据**）。



### list集合有哪些list？哪些list是并发安全的？

- `Arraylist`： `Object[]` 数组
- `Vector`：`Object[]` 数组
- `LinkedList`： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

Vector 是线程安全的（⾥⾯⽅法都带有 synchronized 关键字），效率较低，现在使⽤较少 



### 对list、queue、stack中提供并发操作的容器有哪些？

![image-20220509164106657](appendix/2. JAVASE_6常考面试题/image-20220509164106657.png)

list：

CopyOnWriteArrayList 是 `java.util.concurrent` 包提供的方法，它实现了**读操作无锁，写操作则通过操作底层数组的新副本来实现**，是一种读写分离（读读共享、写写互斥、读写互斥、写读互斥）的并发策略。

queue：

**单端阻塞队列**：其实现有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。

>   `Condition` 是个接口，依赖于 `Lock` 接口的实现，基本的方法就是 `await()` 和 `signal()` 方法。阻塞队列实际上是使用了Condition来模拟线程间协作。
>   调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用 Conditon中的await()对应Object的wait()；

**单端非阻塞队列**：其实现是 ConcurrentLinkedQueue。
**双端非阻塞队列**：其实现是 ConcurrentLinkedDeque。

**双端阻塞队列**：其实现是 LinkedBlockingDeque。

>   使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。
>
>   **阻塞队列：**
>
>   阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。
>    1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
>    2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。
>    阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。
>
>    
>
>   **非阻塞队列：**
>
>   入队和出队操作均利用CAS(compare and set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。



### 介绍下HashMap的数据结构，特点。放一个键值对的流程

**HashMap** **概述：**

1. HashMap 底层是⼀个**数组** ，数组中每个元素是⼀个**单向链表**（即，采⽤拉链法解决哈希冲突）。单链表的节点每个节点是 Node<K, V> 类型（⻅下源码） 

2. 同⼀个单链表中所有 Node 的 hash值不⼀定⼀样，但是他们对应的**数组下标⼀定⼀样**

- 数组下标利⽤哈希函数/哈希算法根据 hash值计算得到的 

4. HashMap 是数组和单链表的结合体 

    1. 数组查询效率⾼，但是增删元素效率较低 
    2. 单链表在随机增删元素⽅⾯效率较⾼，但是查询效率较低 
    3. HashMap 将⼆者结合起来，充分它们各⾃的优点 

5. HashMap 特点 

    1. ⽆序、不可重复

        ⽆序：因为不⼀定挂在那个单链表上了 

    2. 为什么不重复？ 

        通过重写 equals ⽅法保证的

    3. 线程不安全



**放一个键值对的流程(put)**

1. 先将 key, value 封装到 Node 对象中 

2. 底层会调⽤ key 的 hashCode() ⽅法得出 hash 值 

3. 通过哈希函数/哈希算法，将 hash 值转换为数组的下标 

    如果下标位置上没有任何元素，就把 Node 添加到这个位置上； 

    如果下标位置上有但链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进⾏ equals ⽐较 

    ​	-  如果所有的 equals ⽅法返回都是 false，那么这个新节点 Node 将被添加到链表的末尾； 

    ​	-  如果其中有⼀个 equals 返回了 true，那么链表中对应的这个节点的 value 将会被新节点 Node 的value 覆盖。（保证了不可᯿复） 

注： 

1. HashMap 中允许 key 和 value 为 null，但是只能有⼀个（不可重复）！ 

2. HashTable 中 key 和 value 都不允许为 null。 



### HashMap底层机制？扩容过程？get的过程? 并发安全？用安全的Map是什么？

**底层机制**

HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口

HashMap的容量，默认是16

HashMap的加载因子，默认是0.75

当HashMap中元素数超过容量*加载因子时，HashMap会进行扩容。


JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 **key** 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过**(n - 1) & hash**  （范围在-2147483648 到 2147483647）判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key  是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。

JDK 8 之后，对 HashMap 底层数据结构（单链表）进⾏了改进 

1. 如果单链表元素超过8个，则将单链表转变为**红⿊树**； （将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）
2. 如果红⿊树节点数量⼩于6时，会将红⿊树新变为**单链表**。 

这种⽅式也是为了提⾼检索效率，⼆叉树的检索会再次缩⼩扫描范围。提⾼效率



**扩容过程**

HashMap的底层有数组 + 链表(红黑树)组成，数组的大小可以在构造方法时设置，默认大小为16，数组中每一个元素就是一个链表，jdk7之前链表中的元素采用头插法插入元素，jdk8之后采用尾插法插入元素，由于插入的元素越来越多，查找效率就变低了，所以满足某种条件时，链表会转换成红黑树。随着元素的增加，HashMap的数组会频繁扩容，如果构造时不赋予加载因子默认值，那么负载因子默认值为0.75,数组扩容的情况如下:

-   当添加某个元素后，数组的总的添加元素数大于了 数组长度 * 0.75(默认,也可自己设定),数组长度扩容为**两倍**。(如开始创建HashMap集合后，数组长度为16，临界值为16 * 0.75 = 12，当加入元素后元素个数超过12，数组长度扩容为32，临界值变为24)
-   在没有红黑树的条件下，添加元素后数组中某个链表的长度超过了8，数组会扩容为**两倍**.(如开始创建HashMap集合后，假设添加的元素都在一个链表中，当链表中元素为8时，再在链表中添加一个元素，此时若数组中不存在红黑树，则数组会扩容为两倍变成32，假设此时链表元素排列不变，再在该链表中添加一个元素，数组长度再扩容两倍，变为64，假设此时链表元素排列还是不变，则此时链表中存在10个元素，这是HashMap链表元素数存在的最大值，此时，再加入元素，满足了链表树化的两个条件(1:数组长度达到64, 2:该链表长度达到了8)，该链表会转换为红黑树

>   **HashMap 的长度为什么是 2 的幂次方**
>
>   数组下标的计算方法是“ `(n - 1) & hash`”
>
>   前提是 length 是 2 的 n 次方，则hash%length==hash&(length-1)
>
>   位运算快



**get()方法原理**

1. 先调⽤ key 的 hashCode() ⽅法得出 hash 值 

2. 通过哈希函数/哈希算法，将 hash 值转换为数组的下标 

3. 通过数组下标快速定位到数组中的某个位置： 

    如果这个位置上什么也没有（没有链表），则返回 null； 

    如果这个位置上有单链表，此时会将当前 Node 中的 key 与链表上每⼀个节点中的 key 进⾏ equals ⽐较。 

    ​	如果所有的 equals ⽅法返回都是 false，那么 get ⽅法返回 null； 

    ​	如果其中有⼀个 equals 返回了 true，那么这个节点的 value 便是我们要找的 value，此时 get ⽅法最终返回这个要找的 value。 

注： 

1. 放在 HashMap 中 **key 的元素**（或者放在 HashSet 中的元素）需要同时重写hashCode() 和 equals() ⽅法！！！ 

2. get的时间复杂度

    在理想状态下，及未发生任何hash碰撞，数组中的每一个链表都只有一个节点，那么get方法可以通过hash直接定位到目标元素在数组中的位置，时间复杂度为O(1)。

    若发生hash碰撞，则可能需要进行遍历寻找，n个元素的情况下，链表时间复杂度为O(n)、红黑树为O(logn)

    

![image-20220528171441337](appendix/2. JAVASE_6常考面试题/image-20220528171441337.png)



**并发安全**

HashMap不是线程安全的，在并发情况下可能会造成Race Condition，形成环形链表从而导致死循环。在并发场景下要保证线程安全可以使用 Collections.synchronizedMap() 方法来包装HashMap；**Hashtable使用synchronized**来保证线程安全，所有访问HashTable的线程都必须竞争同一把锁，在线程竞争激烈的情况下效率非常低下。

基于此，**ConcurrentHashMap**应运而生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术（JDK1.7）只对所操作的段加锁而不影响客户端对其它段的访问。



**Hashtable和HashMap的区别**

Hashtable

-   底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化
-   初始size为11，扩容：newsize = oldsize*2+1
-   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length
-   Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。

HashMap

-   底层数组+链表+红黑树实现，可以存储null键和null值，线程不安全
-   初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂
-   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
    插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）
-   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀
-   计算index方法：index = hash & (tab.length – 1)
-   HashMap是基于哈希表实现的，每一个元素是一个key(数据类型必须一致)-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。
-   HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。
-   HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。



**HashTable和ConcurrentHashMap区别，以及currentHashmap在jdk7和jdk8实现上有什么变化**

-   Hashtable 

Hashtable 使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

![image-20220423173238391](appendix\Untitled\image-20220423173238391.png)

-   ConcurrentHashMap

在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）对整个桶数组进行了分割分段(`Segment`)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 

到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` **数组+链表+红黑树**的数据结构来实现，**并发控制使用 `synchronized` 和 CAS** 来操作。（JDK1.6 以后 对 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的。（**CAS：Compare and Swap，即比较再交换**） 

![image-20220423173356617](appendix/2. JAVASE_6常考面试题/image-20220423173356617.png)



### 容器中的设计模式

 **迭代器模式**

![image-20220423173949697](appendix/2. JAVASE_6常考面试题/image-20220423173949697.png)

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png"/> </div><br>

**Collection 继承了 Iterable 接口**，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。

从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

```java
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
for (String item : list) {
    System.out.println(item);
}
```

![image-20220528173044459](appendix/2. JAVASE_6常考面试题/image-20220528173044459.png)

**适配器模式**

java.util.Arrays#asList() 可以把数组类型转换为 List 类型。

```java
@SafeVarargs
public static <T> List<T> asList(T... a)
```

应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。

```java
Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
```

也可以使用以下方式调用 asList()：

```java
List list = Arrays.asList(1, 2, 3);
```

![image-20220528173253333](appendix/2. JAVASE_6常考面试题/image-20220528173253333.png)



### 创建了一个类，有属性 String name； int age，重写的equals有两个字段，如果在hashset中放入这个类的实例，会出现什么问题？

想通过SET来实现对类中重复类进行去除，但是类中有些字段重复就认定该类型为重复类型

需要通过SET去除重复：

需要重写hashSet里的方法：

hashSet判断两个对象是否相等，会进行比较hashCode与equals方法

1：会先调用对象的hashCode方法获得hash的值，如果set中哈希表里面没有对应的hash值，则就认定，对象不存在重复的问题。

2：如果set中hash表里面有对应的hash值，就让后面的对象调用equals方法和之前的hash值不同的对象进行比较，如果返回为true就证明存在，不在储存，入伙返回为false则视为新对象，加入到set中。



### 二叉树的深度优先和广度优先区别

深度是dfs

广度是bfs



### 先序中序后序的访问顺序

递归序



### 红黑树

#### 进化过程：

线性查找：性能低

>   查找：O(n)
>
>   增加：O(n)
>   删除：O(n)

出现二叉搜索树（二分查找）：二查叉树会出现退化成链表的问题

>   查找：O(log2N)到O(n)【链表】
>
>   增加：O(log2N)到O(n)【链表】
>
>   删除：O(log2N)到O(n)【链表】+ 可能的一次或多次树的旋转操作

出现AVL平衡二叉树：数据变化有频繁更新节点效率低

>   查找：O(log2N)
>
>   增加：O(log2N)到O(n)【链表】+ 还可能进行额外的旋转操作
>
>   删除：O(log2N)到O(n)【链表】+ 可能的一次或多次树的旋转操作

出现红黑树

>   查找： O(logn)
>
>   ​	因为 h  <= 2 * log2(n+ 1) 
>
>   增加： O(logn)， 0(1)次的旋转操作
>
>   删除： O(logn)， 0(1) 次的旋转操作

总结：红黑树更多是一种折中的选择，它舍弃平衡二叉树的绝对平衡，换取节点插入时尽可能少的调整。

![image-20220531172031591](appendix/2. JAVASE_6常考面试题/image-20220531172031591.png)

#### **适用条件：**

查找频繁：AVL树

插入删除频繁：红黑树



#### **基本属性：**

每个节点要么是红色要么是黑色

根属性：根节点必须是黑色的

叶子节点是黑色的（空指针NIL作为叶子结点了）

红属性：红节点的左右孩子必为黑，黑节点左右孩子可以为黑

黑属性：从任一节点出发到其每个叶子节点的路径，黑色节点的数量是相等的（保证平衡）



#### **基本结论：**

自平衡二叉树，但平衡性没有平衡二叉树好，不严格 < 1，没有一条路径会大于其他路径的2倍

黑色高度（bh）：从任一节点出发到其每个叶子节点的路径，黑色节点的数量。

任意一个节点x，**至少**有internal node的节点个数：2^bh(x)-1

>   推论：n >= 2^bh(root)-1

![image-20220531172726659](appendix/2. JAVASE_6常考面试题/image-20220531172726659.png)

任意一个节点x，bh(x) >= h(x)/2

>   证明：2bh(x) >= bh(x) + rh(x) = h(x)/2

红黑树高度：h  <= 2 * log2(n+ 1) ( 100W个节点，红黑树最大树高40)，n为节点个数

>   证明：
>
>   因为，n >= 2^bh(root)-1
>
>   bh(root) >= h/2
>
>   所以，n>=2^h/2-1
>
>   则得出结论



#### 操作

**插入**

>   变色、旋转（左旋，右旋）

-   空：插入黑色（根）

​	   非空：总是插入红色，然后做如下调整：

-   如果**父节点是黑色**则完成；

​		如果**父节点是红色**则需要做如下调整：（start）

-   检查**父亲的兄弟**（uncle）

    -   如果是**红色**，则反转父亲兄弟和父亲的颜色，从红变黑，再

        -   检查**父亲的父亲**是否是根节点是根节点则结束
        -   不是根节点则重复以上操作(从 start 开始)使之变成红黑树（父亲不是根节点，把父亲变成红色）

        ![image-20220531204922262](appendix/2. JAVASE_6常考面试题/image-20220531204922262.png)

    -   如果是黑色或者没有，需要适当旋转再着色

        ![image-20220531204346252](appendix/2. JAVASE_6常考面试题/image-20220531204346252.png)

    

    

    

### 简述快排？时间复杂度

    快速排序的时间主要耗费在划分操作上，对长度为n的区间进行划分，共需n-1次关键字的比较，时间复杂度为O(n)。
    
        对n个元素进行快速排序的过程构成一棵递归树，在这样的递归树中，每一层最多对n个元素进行划分，所花的时间为O(n)。当初始排序数据随机分布，使每次分成的两个子区间中的元素个数大致相等时，递归树高度为log2n，快速排序呈现最好情况，即最好情况下的时间复杂度为O(nlog2n)。快速排序算法的平均时间复杂度也是O(nlog2n)。所以快速排序是一种高效的算法。


## JVM

### jvm的内存模型、堆和栈都存储了什么

**内存模型**

私有：

-   程序计数器：**线程切换后能恢复到正确的执行位置**

-   虚拟机栈：每个 Java 方法在执行的同时会创建一个**栈帧**用于存储**局部变量表、操作数栈、常量池引用**等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

-   本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 **Native** 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

    （一个Native Method就是一个java调用非java代码的接口）

    **保证线程中的局部变量不被别的线程访问到**

线程共有（进程）：

堆和方法区是所有线程共享的资源，其中**堆**是进程中最大的一块内存，主要用于存放**新创建的对象** (几乎所有对象都在这里分配内存)，
**方法区**主要用于存放**已被加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。



栈：

每个 Java 方法在执行的同时会创建一个**栈帧**用于存储**局部变量表、操作数栈、常量池引用，动态链接，方法返回地址**等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程（先进后出）。

![image-20220506143904277](appendix/2. JAVASE_6常考面试题/image-20220506143904277.png)



**局部变量表**  主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要调用其他方法的场景。**在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic  Reference）保存在 Class  文件的常量池【方法区】里**。**当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用**。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。



堆：

**唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**.

JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为**年轻代**和**老年代**，而非堆内存则为**永久代**（方法区-》元空间）。年轻代又会分为**Eden**和**Survivor**区。Survivor也会分为**FromPlace**和**ToPlace**，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 **8:1:1**。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整



### 常用内存分配策略

**分配内存**

分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的**垃圾收集器是否带有压缩整理功能**决定。



**内存分配的两种方式**

-   指针碰撞 ： 
    -   适用场合 ：堆内存规整（即没有内存碎片）的情况下。
    -   原理 ：用过的内存全部**整合到一边**，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    -   使用该分配方式的 GC 收集器：Serial, ParNew
-   空闲列表 ： 
    -   适用场合 ： 堆内存不规整的情况下。
    -   原理 ：虚拟机会维护一个列表，该列表中会记录**哪些内存块是可用的**，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    -   使用该分配方式的 GC 收集器：CMS

**内存分配并发问题**

虚拟机采用两种方式来保证线程安全：

-   **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

-   **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

    

乐观锁需要**操作和冲突检测**这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。



### 垃圾回收策略

#### 标记-清除算法

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1.  **效率问题**
2.  **空间问题（标记清除后会产生大量不连续的碎片）**

![image-20220506235621595](appendix/2. JAVASE_6常考面试题/image-20220506235621595.png)



#### 标记-复制算法

为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![image-20220506235736545](appendix/2. JAVASE_6常考面试题/image-20220506235736545.png)

应该就是Minor GC的机制把

这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了

不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理



#### 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

![image-20220507001950621](appendix/2. JAVASE_6常考面试题/image-20220507001950621.png)



#### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

**延伸面试问题：** HotSpot 为什么要分为新生代和老年代？

根据上面的对分代收集算法的介绍回答。



### java从编写代码到最终运行的过程

编写的代码如何在各个操作系统上运行起来的？

java文件通过javac编译成.class字节码文件，然后 由jvm加载字节码，运行时解释器将字节码解释为机器码。在运行期间，即时编译器会针对热点代码将该部分字节码编译成机器码，以获得更高的执行效率。在整个过程中，即时编译器和解释器相互配合，提高速度。

 

java类加载（加载字节码的过程）

目的：把javac编译过的class文本文件通过加载，生成某种形式的class数据结构进入内存，程序可以调用这个数据结构构出object。该过程在运行时进行。

过程：

-   加载：读取一个【class文件】，将其转换成某种【静态数据结构】存储在【方法区】中，并在【堆】中生成一个便于用户调用的【java.lang.Class类型的对象】（用户主导：读取二进制流）

-   验证：文件格式验证（在加载阶段） -> 元数据、字节码验证（对class静态结构进行语法和语义上的分析，保证其不会危害虚拟机的行为）-> 符号引用验证码（在解析阶段）

-   连接准备：为该类中定义的【静态变量】赋0值

-   连接解析：符号引用替换为直接引用。

    一个java类A被编译成class之后,并且引用了类B，编译阶段A不知道B有没有被编译，并且此时类B没有被加载，所以不知道类B的实际地址。此时，在类A的class文件中，使用一个字符串S代表B的地址，S则被成为符号地址。

    运行时，A发生了类加载，解析时类B 还没加载，就触发B的类加载，将B加载到虚拟机中，类A的符号引用被替换成B的实际地址，这是直接引用。

    静态解析：A调用B的具体实现类

    动态解析： 类B是抽象类/接口，类C、D是B的实现类，此时不知道用B的哪个实现类进行替换。当运行时发生调用，此时虚拟机调用栈中得到了具体的类型信息，再进行直接引用替换 。

-   初始化：主动资源初始化：成员变量的赋值、静态变量的赋值、静态代码块指令（用户主导：整个初始化部分） 



执行main方法的步骤如下:

1.  编译好 App.java 后得到 App.class 后，执行  App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App  的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载
2.  JVM 找到 App 的主程序入口，执行main方法
3.  这个main中的第一条语句为 Student student = new Student("tellUrDream") ，就是让 JVM  创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把  Student 类的信息放到方法区中
4.  加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 **指向方法区中的 Student 类的类型信息** 的引用
5.  执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到**方法区中 student 类的类型信息的方法表**，获得 sayName() 的字节码地址。
6.  执行sayName()

其实也不用管太多，**只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找**



### 如何破坏双亲委派机制

**重写loadclass()方法破坏双亲委派模型**
loadclass的作用就是通过指定的全限定名加载class。这里最主要的是重写loadclass()方法，因为**双亲委派机制的实现就是通过这个方法实现的，这个方法可以指定类通过什么加载器来加载，所以如果我们改写他的规则，就相当于打破了双亲委派机制。**默认的过程就是这样的，先判断这个类是不是已经被当前层的类加载器加载过了，如果没有加载过就将该类委派给父类加载器，如果父类加载器无法加载就向下传递，回来由自己来进行加载，重写这个方法以后就能自己定义使用什么加载器了，也可以自定义加载委派机制，也就打破了双亲委派机制。重写loadclass() 也就有可能将findclass()也重写。



**线程上下文类加载器破坏双亲委派模型**
双亲委派模型的局限性：**父类加载器无法加载子类加载器路径中的类**。双亲委派模型最典型的不适用场景是SPI的使用。所以提供了一种线程上下文类加载器，能够使父类加载器调用子类加载器进行加载。
简单来说就是**接口定义在了启动类加载器中，而实现类定义在了其他类加载器中**，当启动类加载器需要加载其他子类加载器路径中的类时，使用了**线程上下文类加载器**（默认是应用程序类加载器）来实现父类调用子类的加载器进行类的加载。

>   在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为他们提供实现，如常见的SPI有JDBC、JNDI等，这些SPI的接口属于Java核心库，一般存在rt.jar包中，由bootstrap类加载器加载，而SPI的第三方实现代码则是作为Java应用所依赖的jar包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由Bootstrap类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派机制的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。

![image-20220512160217044](appendix/2. JAVASE_6常考面试题/image-20220512160217044.png)



## 设计模式

### 实现一个单例

单例模式是一种常用的设计模式，是23中设计模式中的一种。

设计模式:设计模式是一种思想，是一种编程思想，是前人经验的累积。

单例模式概念：**在做某个项目中，创建了一个类，那么这个类只能生成一个对象**。

单例模式有两种实现方式分别：饿汉式和懒汉式

**饿汉式**

饿汉式：顾名思义，可以理解成一个饿汉，只要一加载类的时候就会创建了对象，因为用了static修饰，static修饰的成员随着类的加载而加载的

**实现步骤：1：构造函数私有化**

　　　　　**2：提供一个静态对象属性用来接收对象**

　　　　　**3：创建一个静态方法用来获取对象实例**

具体代码如下：

```java
//那么怎么让这个类在整个项目中生成一个对象呢？使用单例模式
    //单例模式第一种：饿汉式
    //弊端：占用内存，如果我不想随着类的加载而加载，想延迟加载创建对象？需要用到懒汉式
    //为什么叫饿汉式呢？一加载类的时候就创建了对象，因为用了static修饰，static修饰的成员随着类的加载而加载
    //1.第一步：构造方法需要私有化
    //2.第二步：提供一个静态对象属性用来接收对象
    //3.第三步：提供一个静态方法用来获取对象
    //随着类的加载就马上创建了对象，很叽饿
    public static Single s=new Single();
    //私有的只能在本类中使用
    private Single(){}
    public static Single getSingle(){
        return s;
    }
```



**懒汉式**

懒汉式：比较懒的加载，不会随着类的加载而加载，而是在你调用创建对象实例的方法时才会创建对想

实现步骤：

```
第一步：构造方法需要私有化
第二步：提供一个静态属性
第三步：提供一个方法用来创建对象
```

代码实现如 :

```java
 //懒汉式:顾名思义，这个是比较的懒的，在我们加载类的时候没有创建对象，而是在你调用了方法的时候才创建
    //第一步：构造方法需要私有化
    //第二步：提供一个静态属性
    //第三步：提供一个方法用来创建对象
    public static LazySingle lazySingle;
    private LazySingle(){}
    public static LazySingle getLazySingle(){
        //这里面需要创建对象
        //怎么解决？也就是说如何避免两个不同的线程创建不同的对象？
        //判断对象是否为空，为空进去创建，不为空就不能够创建
        //需要使用同步把生成的对象的相关代码锁起来（同步代码块或者同步方法都可以）
        // synchronized(锁对象) {}  LazySingle.class字节码对象
        //LazySingle加载到内存中去会编译成LazySingle.class文件，
        // 到JVM内存中，首先会加载到方法区，
        // 方法区中可能不止一个LazySingle.class文件，可能会有Dag.class,Cat.class...
        // 这样方法区中会存在很多的字节码文件，用面向对象的思维编写它，专门用一个类称呼它Class类
        //那么每一个字节码文件可以看成是一个字节码文件对象
//        Class<LazySingle> lazySingleClass = LazySingle.class;//Class类，Class类中的 LazySingle.class对象
        //还没有很完善，因为使用同步代码块会存在开锁和关锁的一个步骤，会降低执行效率，损耗时间
        //而且不同的线程去访问它的时候都要执行同步代码块，会降低执行效率，消耗时间
        //因为使用同步代码块会降低执行效率，消耗时间，为了避免减少使用同步代码块的一个次数
        //需要判断如果对象为空的时候才进入同步代码块
        //假如没有创建对象之前，两个不同的线程同时进入，那么所创建的对象也不一样
        // 就需要用同步代码块把生成对象的相关代码锁起来
        // 锁对象使用类的字节码对象 因为使用同步代码块会消耗时间
        // 为了避免减少使用同步代码块的次数，需要判断对象为空的时候，才进入同步代码块
        //这里是进行了双重检查 两个if判断
        if(lazySingle==null) {//如果不等于就不要创建，等于null创建 有利于提升执行效率
            synchronized (LazySingle.class) {//锁对象使用字节码对象
                //如何避免两个线程创建创建不同的对象
                //判断对象是否为空
                //判断对象是否为空，为空进去创建，不为空就不能够创建
                if (lazySingle == null) {
                    lazySingle = new LazySingle();
                }
            }
        }
        return lazySingle;
    }

    public void eat(){
        System.out.println("大口吃饭");
    }
```

>   第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，**第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。**
>
>   
>
>   第二次判断是为了避免以下情况的发生。
>    (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.
>    (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。
>    (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。
>
>   另外，需要注意 `uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要。
>
>   `uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：
>
>   1.  为 `uniqueInstance` 分配内存空间
>   2.  初始化 `uniqueInstance`
>   3.  将 `uniqueInstance` 指向分配的内存地址
>
>   但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。
>
>   
>
>   **使用 `volatile` 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行**。
>
>   有一个误区：就是认为已经有Synchronized，怎么会被抢占？
>
>   但是需要注意的是，Synchronized只是为了保证同步，也就是当有多个线程对同一段程序进行操作时，能够保证只有一个线程能够获取到资源，至于是谁获取资源，可不可以抢占它不管的。







### 工厂设计模式

https://blog.csdn.net/qq_43613445/article/details/107976721

#### 概念

一、设计模式

1.   什么是设计模式

     设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

2.   应用设计模式有什么好处？

     设计模式是优秀的使用案例，使用设计模式可提高代码的重用性，让代码更容易被他人理解，保证代码可靠性。

     

二、工厂模式

1.   工厂模式的概念

     工厂模式顾名思义就是创建所需要的对象，可以代替传统的new创建对象方式。
     它是一种创建型模式，用于封装和管理对象的创建。

     工厂模式包括简单工厂模式、抽象工厂模式和工厂方法模式，抽象工厂模式是工厂方法模式的扩展。抽象工厂模式不常用。

2.   工厂模式的意念

     定义一个接口来创建对象，让子类来决定哪些类需要被实例化。工厂方法把实例化的工作推迟到子类中实现。

3.   工厂模式的应用场景

     有一组同类型或类似的对象需要创建
     在编码时不能预见需要创建哪种类的实例
     
     系统需要考虑扩展性，不应依赖于产品类实例如何被创建、组合和表达的细节。
     
     同一类型的对象需要创建。

4.   工厂模式的动机

     项目中的现状:

     在软件系统中经常面临着“对象”的创建工作，由于需要的变化，这个对象可能随之也会发生变化，为此，我们需要提供一种封装机制来隔离出这个易变对象的变化，从而保持系统中其他依赖该对象的对象不随着需求变化而变化。

     

     基于项目现状将代码进行如下设计：

     尽量松耦合，一个对象的依赖对象的变化与本身无关；
     具体产品与客户端剥离，责任分割。

     

#### 工厂模式的应用

包结构目录

![image-20220509192615004](appendix/2. JAVASE_6常考面试题/image-20220509192615004.png)

工厂，生产冰淇淋和冰棒



##### 传统方式实例对象

IceProjectInterface.java

```java
package com.ice;

/**
 * 冰棒产品接口
 */
public interface IceProjectInterface{
	/**
	 * 打印信息方法
	 */
	public void showInfo();
}

```

 IceCreamImpl.java

```java
package com.ice.impl;

import com.ice.IceProjectInterface;

/**
 * 冰淇淋实现类
 */
public class IceCreamImpl implements IceProjectInterface{
	@Override
	public void showInfo() {
		System.out.println("这里是冰淇淋");
	}
}

```

IceLollyImpl.java

```java
package com.ice.impl;

import com.ice.IceProjectInterface;
/**
*冰棒实现类
*/
public class IceLollyImpl implements IceProjectInterface{
	@Override
	public void showInfo() {
		System.out.println("这里是冰棒");
	}
}

```

IceProjectTest.java

```java
package com.ice.test;

import com.ice.IceProjectInterface;
import com.ice.impl.IceCreamImpl;

/**
 * 冰棒产品测试类
 */
public class IceProjectTest{
	public static void main(String[] args){
		//传统方法
		IceProjectInterface iceCream = new IceCreamImpl();
		iceCream.showInfo();
	}
}

```



##### 简单工厂模式

首先创建一个Factory工厂类

IceProjectFactory.java

```java
package com.ice.factory;

import com.ice.IceProject;
import com.ice.impl.IceCreamImpl;
import com.ice.impl.IceLollyImpl;

/**
 * 冰棒产品工厂类
 */
public class IceProjectFactory{
	/**
	*根据参数创建对象
	*@param name 冰棒产品名称
	*/
	public IceProjectInterface iceProjectByName(String name){
		if("ice-cream".equals(name)){
			return new IceCreamImpl();
		}else if("ice-lolly".equals(name)){
			return new IceLollyImpl();
		}
		return null;
	}
}
```

IceProjectTest.java

```java
package com.ice.test;

import com.ice.IceProject;
import com.ice.factory.IceProjectFactory;
import com.ice.impl.IceCreamImpl;

/**
 * 冰棒产品测试类
 */
public class IceProjectTest{
	public static void main(String[] args){
		IceProjectInterface iceCream = new IceProjectFactory().iceProjectByName("ice-cream");
		iceCream.showInfo();
	}
}
```

##### 工厂方法模式

使用这种方式来创建对象时，每增加一个类，我们需要在方法中多添加一个if结构，我们可以使用反射机制，优化代码，并根据类的名称来为我们创建类的实例。

IceProjectFactory.java

```java
   /**
	 * 根据类名创建对象
	 * @param className 类名
	 * @return 返回所需对象
	 */
	public IceProjectInterface iceProjectByClass(String className){
		try {
			IceProjectInterface iceProject = (IceProjectInterface)Class.forName(className).newInstance();
			return iceProject;
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		return null;
	}
```

IceProjectTest.java

```java
	IceProjectInterface iceCream = new IceProjectFactory().iceProjectByClass("com.ice.impl.IceCreamImpl");
	iceCream.showInfo();
```

##### 使用映射配置类路径

由于根据类名来查找创建对象，类名过长，我们可以使用简写key的形式，创建映射文件来配置类路径。

type.properties

```java
ice-cream = com.ice.impl.IceCreamImpl
ice-lolly = com.ice.impl.IceLollyImpl
```

 IceProjectFactory.java

```java
   /**
	 * 根据key创建对象
	 * @param className 类名
	 * @return 返回所需对象
	 */
	public IceProjectInterface iceProjectByClassKey(String key){
		try {
			Map<String, String> map = new PropertiesReader().getProperties();
			IceProjectInterface iceProject = (IceProjectInterface)Class.forName(map.get(key)).newInstance();
			return iceProject;
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		return null;
	}

```

IceProjectTest.java

```java
		IceProjectInterface iceCream 
		= new IceProjectFactory().iceProjectByClassKey("ice-cream");
		iceCream.showInfo();

```

#### 工厂方法模式和抽象工厂模式对比

-   工厂方法模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广；
-   工厂方法模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构；
-   工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。



#### 常见应用

-   JDBC

是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组Java语言编写的类和接口组成。

-   Spring BeanFactory

Spring BeanFactory作为Spring基础的IOC容器，是Spring的一个Bean工厂。单从工厂模式的角度思考，它就是用来生产Bean，提供给客户端。


#### 工厂模式的好处

-   工厂模式是为了解耦：可以将对象的创建和使用分离，如果不分离，不但违反了设计模式的开闭原则，需要需要使用另一个子类的话，需要修改源代码 ,把对象的创建和使用的过程分开。
-   工厂模式可以降低代码重复。
-   因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误

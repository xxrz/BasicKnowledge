# 七层网络协议

## 七层网络协议是什么

![image-20220516203308922](appendix\5. 计算机网络_1常考题\image-20220516203308922-1652965394477.png)



![image-20220516201426874](appendix\5. 计算机网络_1常考题\image-20220516201426874.png)

网络OSI参考模型分为(从上到下):应，表，会，传，网，数链，物
    物理层->数据链路层->网络层->传输层->会话层->表示层->应用层。

**1，物理层（网卡）：**是模型的最低层，物理层涉及在信道上传输的**原始比特**流。该层是网络通信的数据传输介质，由连接不同结点的电缆与设备共同构成。功能是：利用传输介质为数据链路层提供物理连接，用于计算机之间的数据传输，传输bit流。负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换。在这一层，数据的单位称为比特（bit）。

**2，数据链路层（交换机）：**模型的第二层，数据链路层的主要任务是**加强物理层传输原始比特流的功能**，使之对应的网络层显现为一条无错线路。发送包把输入数据封装在数据帧，按顺序传送出去并处理接收方回送的**确认帧**。主要功能是：负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信），传输以“帧”为单位的数据包，该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。对bit数据格式化，校验。目的是保障数据传输可靠性。采用**差错控制与流量控制**方法，使有差错的物理线路变成无差错的数据链路。在这一层，数据的单位称为帧。

**3，网络层（路由选择，点到点）：**第三层，网络层关系到子网的运行控制，其中一个关键问题是确认从源端到目的端如何选择路由。主要功能是：为数据在节点之间传输创建**逻辑链路**，IP寻址，通过IP连接网络上的计算机。将数据传输到目标地址；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻找地址和路由选择。通过路由实现不同局域网间的通信。通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现**拥塞控制**、**网络互连**等功能。在这一层，数据的单位称为**数据包（packet）**。

**4，传输层（端到端）：**第四层，传输层的基本功能是**从会话层接收数据而且把其分成较小的单元传递给网络层**。只在通信双方的节点上（比如**计算机终端）进行处理**，而无需在路由器上处理，主要功能是：建立了主机端到端服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。主要关注tcp、udp。ipv6传输效率高就和这层有关。在这一层，数据的单位称为**数据段**（segment）。

主要功能：

（1）：为端到端连接提供传输服务

（2）：这种传输服务分为可靠和不可靠的,其中Tcp是典型的可靠传输,而Udp则是不可靠传输

（3）：为端到端连接提供**流量控制,差错控制,服务质量**(Quality of Service,QoS)等管理服务

包括的协议如下：

TCP：传输控制协议，传输效率低，可靠性强

UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据（比如QQ）

**5，会话层（会话控制）**：第五层，会话层允许不同机器上的用户**建立会话关系**。主要功能是：负责维护两个结点之间的传输连接，以便确保点到点传输不中断，以及管理数据交换等功能。管理不同设备之间通信。

**6，表示层（数据格式转化）：**第六层，表示层用来完成某些特定的功能。对应用层数据编码和数据格式转换，保障不同设备之间通信（windows和linux）。主要功能是：用于处理在两个通信系统中交换信息的表示方法，主要包括**数据格式变换、数据加密与解密、数据压缩与恢复等功能**。

**7，应用层**：模型的最高层，应用层包含着大量人们普遍需要的协议。主要功能是：**提供应用接口**，为用户直接提供各种网络服务，比如**文件服务器、数据库服务、电子邮件与其他网络服务**。
![image-20220519210423531](appendix\5. 计算机网络_1常考题\image-20220519210423531.png)



# TCP和UDP

## TCP和UDP区别以及应用场景

**运输层主要使用以下两种协议：**

1.  **传输控制协议 TCP**（Transmisson Control Protocol）--提供**面向连接**的，**可靠的**，面向字节流的数据传输服务。
2.  **用户数据报协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。



### TCP与UDP的区别

-   TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；

    UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；

-   TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；

    UDP通信类似于学校广播，靠着广播播报直接进行通信。

-   TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；

-   TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。

-   TCP首部开销（20字节）比UDP首部开销（8字节）要大

-   UDP 的主机不需要维持复杂的连接状态表

    

### TCP和UDP的应用场景

对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍；

其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情况



## TCP的可靠性如何保证？

1.  应用数据被分割成 TCP 认为最适合发送的数据块。
2.  TCP 给发送的每一个包进行编号，接收方对数据包进行**排序**，把有序数据传送给应用层。
3.  **校验和：** TCP 将保持它首部和数据的检验和。这是一个**端到端的检验和**，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4.  TCP 的接收端会丢弃重复的数据。
5.  **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP  的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP  使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用**滑动窗口**实现流量控制）
6.  **拥塞控制：** 当网络拥塞时，减少数据的发送。全局的。
7.  **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。（自动重传请求）
8.  **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段



## 介绍TCP重传

-   ### ARQ 协议

    **自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI  模型中数据**链路层和传输层**的**错误纠正协议**之一。它通过使用**确认和超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括**停止等待 ARQ 协议**和**连续 ARQ 协议。**
    
    
    
    #### 停止等待 ARQ 协议
    
    停止等待协议是为了实现可靠传输的，它的基本原理就是**每发完一个分组就停止发送，等待对方确认**（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，**直到收到确认后再发下一个分组。**
    
    在停止等待协议中，若**接收方收到重复分组，就丢弃该分组，**但同时还要发送确认。
    
    **优缺点：**
    
    - **优点：** 简单
    - **缺点：** 信道利用率低，等待时间长
    
    **1) 无差错情况:**
    
    发送方发送**分组**, 接收方在规定时间内收到, 并且回复确认。 发送方再次发送。
    
    **2) 出现差错情况（超时重传）:**
    
    **停止等待协议**中**超时重传**是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。
    
    **3) 确认丢失和确认迟到**
    
    - **确认丢失** ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A  并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. **丢弃这个重复的 M1 消息**，不向上层交付。 2. **向 A 发送确认消息**。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。
    - **确认迟到** ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B  仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B  第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到**重复的确认**后，**直接丢弃**。2. B 收到**重复的 M1**  后，也**直接丢弃**重复的 M1
    
    
    
    #### 连续 ARQ 协议
    
    **连续 ARQ 协议** 可提高信道利用率。发送维持一个**发送窗口**，凡位于发送窗口内的分组可连续发送出去，而**不需要等待对方确认**。接收方一般采用**累积确认**，对按序到达的**最后一个分组发送确认**，表明到这个分组位置的所有分组都已经正确收到了。
    
    **优缺点：**
    
    - **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。
    - **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3  号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 **Go-Back-N（回退  N）**，表示需要退回来重传已经发送过的 N 个消息。（中间有一个没有收到断了就断了）
    

## 介绍滑动窗口

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。



窗口是缓存的一部分，用来暂时存放字节流。**发送方和接收方各有一个窗口**，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口**向右滑动一定距离**，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

**接收窗口只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![image-20220519212339125](appendix\5. 计算机网络_1常考题\image-20220519212339125.png)



## TCP协议字段

![image-20220519212251662](appendix\5. 计算机网络_1常考题\image-20220519212251662.png)

-   **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

-   **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

-   **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

-   **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

-   **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-   **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-   **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

    

## TCP连接中收到一个废报文，状态会怎么切换？

- **确认丢失** ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A  并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. **丢弃这个重复的 M1 消息**，不向上层交付。 2. **向 A 发送确认消息**。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。

  



## 为什么ack=seq+1

因为确认应答的是seq序列

ack=seq+1这么设计的目的是确保建立连接的双方都是真实的对方,而不是被某个中间人冒充的。ack和seq都是两个整型变量,表示序列号;



#### 为什么TCP客户端最后还要发送一次确认呢？

主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



## TCP三次握手四次挥手，分别状态

### TCP 三次握手

#### 简单版

![image-20220518201044954](C:\Users\Lenovo\Desktop\BasicKnowledge\appendix\5. 计算机网络_1常考题\image-20220518201044954.png)

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端

- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端

- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

  > 在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN （同步请求）消息，服务器使用 SYN-ACK同步请求应答）  应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP  连接（三次握手），数据才可以在客户机和服务器之间传递



#### 详细版

​	在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

2. 第一次握手：建立连接时，客户端发送SYN 包(SYN = 1,seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认。（TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。）

3. 第二次握手：服务器处于listen状态，收到SYN 包，必须确认客户的SYN（ack= x+1, ACK=1,），同时自己也发送一个SYN包（SYN=1,seq = y），即SYN+ACK包，此时服务器进入SYN_RECV(同步收到)状态。（这个报文也不能携带数据，但是同样要消耗一个序号。）

4. 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1，ACK=1，seq = x +1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态(建立连接)，完成三次握手。（TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。）

5. 完成三次握手，客户端与服务器开始传送数据

![image-20220518201213997](appendix\5. 计算机网络_1常考题\image-20220518201213997.png)

> seq指发送序列
>
> ack指确认序列
>
> SYN指发送报文
>
> ACK指回应报文
>
> 理解：
>
> 所有消息都有序列，按发送方起始序列+1
>
> ack是回应序列，右发送序列+1

![image-20220518204537166](appendix\5. 计算机网络_1常考题\image-20220518204537166.png)



### TCP四次挥手

#### 简单版



![image-20220518204956638](C:\Users\Lenovo\Desktop\BasicKnowledge\appendix\5. 计算机网络_1常考题\image-20220518204956638.png)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个 FIN 给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

简单易懂：

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 **B 可能还会有要说的话，A 不能要求 B  跟着自己的节奏结束通话**，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

> 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

> FIN结束报文
>

#### 详细版

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 （TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。）

2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，**客户端向服务器的方向就释放了**，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是**服务器若发送数据，客户端依然要接受**。这个**状态还要持续一段时间**，也就是整个**CLOSE-WAIT**状态持续的时间。
   客户端收到服务器的确认请求后，此时，客户端就进入**FIN-WAIT-2（终止等待2）状态**，**等待服务器发送连接释放报文**（在这之前还需要接受服务器发送的最后的数据）。

3. **服务器将最后的数据发送完毕后**，就向客户端**发送连接释放报文**，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

4. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，**客户端就进入了TIME-WAIT（时间等待）状态**。注意此时TCP连接**还没有释放**，**必须经过2 *MSL（最长报文段寿命）的时间后**，当客户端撤销相应的TCB后，才进入**CLOSED状态**。
   **服务器**只要收到了客户端发出的确认，立即**进入CLOSED状态**。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

   ![image-20220518211129158](appendix\5. 计算机网络_1常考题\image-20220518211129158.png)



## 为什么TCP建立要三次、断开要四次

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，**服务器**收到对方的FIN报文时，**仅仅表示对方不再发送数据了但是还能接收数据**，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送**FIN报文给对方来表示同意现在关闭连接**，因此，**己方ACK和FIN一般都会分开发送，从而导致多了一次。**



## 半连接状态是什么？

发生在TCP三次握手中，如果A向B发起连接，B也按照正常情况下响应了，但是A**不进行三次握手，这就是半连接**。

客户端向服务端发起连接请求，服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放到一个队列里，我们将这种队列称之为半连接队列。
**全连接队列就是已经完成了三次握手**，建立起连接就会放到全连接队列中去，如果全连接队列满了就可能会出现丢包的现象。

> 补充关于SYN-ACK重传次数的问题:
>
> 服务器发送完SYN-ACK包，如果未收到客户端确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
> 每次重传等待的时间一般不同，一般是指数增长。如时间间隔是1，2，4，8




## TCP拆包、粘包，如何解决这个问题

TCP协议是**面向字节流的**，TCP没有**消息边界保护**的功能，所以TCP就会发生**粘包**和**拆包**的问题。

这一点不像UDP，因为**UDP面向报文**，所以它不会对报文进行处理，而是直接将报文作为一个整体，添加UDP头部（ 粘包拆包问题在数据 “链路层、网络层、传输层” 都可能发生）



### 粘包/拆包问题产生原因

- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。

- 待发送数据大于MSS（TCP报文长度 - TCP头部长度 > MSS最大报文长度），TCP在传输前将根据MSS大小进行拆包分段发送。

  > MTU 最大传输单元 （链路层）：
  >
  > 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）
  >
  > MSS TCP最大段大小 Maximum Segment Size（传输层 - 可传输tcp数据包大小）
  >
  > 一般，在以太网中 TCP 的 MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= **1460**
  >
  > ![image-20220519231528998](appendix\5. 计算机网络_1常考题\image-20220519231528998.png)
  >
  >  **总结：**IP 数据包长度超过链路的 MTU 时，在发送之前需要分片，而 TCP 层为了 IP 层不用分片主动将包切割成 MSS 大小。

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据包合并为一次发送，将发生粘包（Nagle算法优化，避免tcp报文头重脚轻的情况发生）

- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。



### 解决方法

解决问题关键在于如何给每个数据包**添加边界信息用于区分不同数据包**

- 消息分为TCP首部和TCP消息体，TCP首部中**应保存数据包的长度**（TCP的首部**原本是没有**表示数据长度的字段，因为可由**IP层计算**出：TCP包长度 = IP首部的数据包长度 - IP首部长度，再由TCP包长度可知数据的长度）。这样接收端在接收到数据后，通过读取包首部的长度字段，就知道每个数据包的实际长度了。
- **发送端在每个包的末尾使用固定的分隔符**（如 \r\n），这样接收端通过这个边界就可以将不同的数据包拆分开（如 **FTP协议**）。
- **发送端将每个数据包封装为固定长度**（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。不推荐这种方式，尤其是在高并发大流量的业务场景下，会消耗不必要的资源



# HTTP协议

## http的请求头有什么？请求方法在哪个部分？ cookie是放在哪个部分？空行的作用？

> 当我们设计一个通信协议时，“消息头/消息体”的分割方式是很常用的，**消息头告诉对方这个消息是干什么的，消息体告诉对方怎么干**。HTTP协议传输的消息也是这样规定的，每一个HTTP包都分为HTTP头和HTTP体两部分，消息体是可选的，而消息头是必须的。每当我们打开一个网页，在上面点击右键，选择“查看源文件”，这时看到的HTML代码就是HTTP的消息体，那么消息头可以通过浏览器的开发工具或者插件可以看到
>
> 客户端通过发送 HTTP 请求向服务器请求对资源的访问。 它向服务器传递了一个数据块，也就是请求信息，HTTP 请求由三部分组成：请求行、 请求头和请求正文。
>
> 

**请求行：**请求方法URI协议/版本

POST /index.php HTTP/1.1

##### 请求报头

请求报头允许客户端向服务器传递请求的**附加信息**和**客户端自身的信息**。
PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。
**常见的请求报头**: 

Accept, Accept-Charset:接受哪些类型的信息

Accept-Encoding: 指定接受的编码方式
Accept-Language：语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持链接(Keep-alive)
HOST：主机

Accept-Language, Content-Type, Authorization, Cookie, User-Agent等

##### 请求正文

当**使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中**。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。



**Cookie在请求头中**

作用： 最重要的header, 将cookie的值发送给HTTP 服务器







## http是哪层协议？HTTP请求有哪些



## get/post区别

`【提交请求】：**获取资源**，**请求服务器发送某个资源**，用来请求访问已被URI（统一资源标志符，和URL是包含和被包含的关系）识别的资源。(一般用于**获取数据**)

`POST`【提交数据】：用来**传输实体的主体**，**向服务器提交数据**,  虽然GET也可以实现，但是一般不用。



## http请求的一个过程



## 对http协议的了解/发展是什么，https协议的了解。两者的区别是什么？



## https是什么？加密时怎么传递密钥？



## cookie和session的区别

Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如 ① 我们在 Cookie 中**保存已经登录过的用户信息**，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；②  一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 **Token** 在  Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③  登录一次网站后访问同网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

**Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端**。

Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密。



## 登录态怎么保证





## 某个网页打不开，不是网络问题，原因分析



# 网络层

## DNS是哪一次层的？



# 传输层

## 传输层用的什么协议，为什么用？

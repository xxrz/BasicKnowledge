# Java面向对象

![image-20220427135519319](appendix\2. JAVASE_1面向对象\image-20220427135519319.png)

## 1. 面向对象和面向过程

#### 区别

面向过程：

先确定如何操作数据，再决定数据的结构。适⽤于**⼩规模**问题; 

⾯向对象OOP：

先决定数据的结构，在考虑操作数据的算法。适⽤于**⼤规模**问题



面向对象开发的程序一般更易维护、易复用、易扩展。



#### 面向对象的三大特征

- 继承

  子类不仅可以继承父类的方法，还可以增加新的方法，但不能的选择性的继承父类。

  好处：可以快速创建新类，提高代码重用，程序的可维护性

  特征：

  - 子类拥有父类的所有属性和方法（**包括私有**），但是父类中的私有属性和方法子类无法访问，只是拥有
  - 子类可以拥有自己属性和方法
  - 子类可以用自己的方法实现父类

  

- 封装

  **定义：将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式**

  一个类不能直接调用其他类的实例变量，通过getter,setter

  （也就是把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象内部的信息）

  

- 多态

  定义：多态是一个对象可以有多种状态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。引用类型的值是对象。

  一个对象变量可以指示多种实际类型的现象叫多态

  分类：

  - 编译时多态：比如重载
  - 运行时多态：比如重写（动态绑定）

  多态的实现机制：

  父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是运行期才动态绑定的，那么**引用变量所指向的具体实例对象在运行期才确定**。所以这个对象的方法是运行期正在内存运行这个对象的方法而不是引用变量的类型确定的。

  特征：

  - 对象类型和引用类型之间具有继承（类）和实现（接口）的关系
  - 引用类型变量发出的方法调用到底是哪个类中的方法运行时才能确定
  - 多态不能调用只在子类存在不在父类存在的方法
  - 如果子类重写了父类的方法，真正执行的是子类的方法



#### 面向对象原则

- 封装：绝对不能让类中的方法直接访问其他类的实例字段
- 扩展：可以通过扩展其他类扩展来构建新类





## 2. 基本数据类型



#### 成员变量和局部变量

成员变量：

- 语法形式：属于类，可以被static，final修饰
- 存储方式：如果成员变量被static修饰，成员变量属于类，若没有被static修饰，属于对象，对象存储在堆
- 生存时间：对象创建即存在
- 自动赋值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值）

局部变量：

- 属于方法、代码块，不可被访问控制修饰符合static修饰，可以被final修饰
- 存储在栈
- 方法调用而消亡
- 不会自动被赋值



#### 基本类型和包装类型的区别

- 包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

- 包装类型可用于泛型，而基本类型不可以。

- **基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中**，**基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中**。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。

- 相比于对象类型， 基本数据类型占用的空间非常小



## 3. 对象

#### 创建对象的运算符（new），对象类型和引用类型的不同

对象实体：值，存储在堆中，可以被n个引用指向

对象引用：对象引用指向对象实体的地址（该地址存在栈中），可以指向0-1个实体



#### 对象相等和引用相等的区别

对象相等：指的是存储在内存中的内容

引用相等：指的是存储在内存中的实体是不是一个，也就是地址



#### 注意

- 对象的状态是封装的，要改变必须通过调用方法
- 对象的状态不能完全描述一个对象，每个对象有一个唯一标识
- java中对象变量是多态的





## 4. 类

#### 类之间的关系

- **依赖**（uses-a）:一个类的方法使用另一个类的对象

  （关系对象出现在局部变量或者方法的参数里，或者关系类的静态方法被调用 ）

- **聚合**(has-a)：类A的独享包含类B的对象

  （关系对象出现在实例变量中）

- 继承(is-a): 子类和父类

  

#### 类的构造方法

创建对象，完成对象的初始化工作



#### 如果一个类没有声明构造方法，该程序可以正确执行吗

可以。如果没有构造方法，则会有默认无参的构造方法。但如果类中我们定义了类的有参构造，java就不会再添加默认的无参构造了。



#### 构造方法有哪些特点？是否可以被override?

- 如果没有构造方法，则会有默认无参的构造方法；但如果类中我们定义了类的有参构造，java就不会再添加默认的无参构造了
- 方法和类名一样
- 没有返回值，但不用用void声明构造函数
- 生成类的对象时自动执行，无需调用

**构造方法不能被重写（override），但可以被重载（overload），可以通过参数列表进行区别**



#### 接口和抽象类有什么共同点和区别

共同点：

- 都不能被实例化
- 都可以抽象方法
- 都可以有默认实现的方法

区别：

- 接口强调行为，实现了某个接口，就对应了行为

  抽象类强调所属关系，用于代码复用

- 一个类只能继承一个类，但是可以是想多个接口

- 接口中的成员变量只能是public final static，不能被修改，且必须有初始值

  抽象类的成员变量默认是Default，可重新定义



#### 抽象类

- 唯一目的就是被继承

- 好处：多态

  因为继承抽象类的子类都可以重写或者重载抽象类的方法

- abstract关键字

  - 修饰方法

    抽象方法，不用实现，在具体的子类中实现

    若子类中没有实现抽象方法，仍然要定义为抽象类

  - 修饰类

    抽象类，包含一个或多个抽象方法

    抽象类也可以包含字段和具体方法

- 提高程序清晰度

  - 父类定义，子类实现

  - 变量定义为父类类型，具体实现子类类型（上转）

    ```java
    List<Integer> x = new LinkedList<>();
    ```

  - 方法调用，通过父类变量（多态，动态绑定）



### 预定义的类

在Java中，没有类就无法做任何事情，但并非所有的类都可以进行实例化，产生对象。例如：Math类

这样的类，一般只封装了功能，而不需隐藏数据，因为它根本没有数据。

由于没有数据，因此也不必考虑创建对象和初始化他们的实例字段，因为根本没有实例字段。

- 对象与对象变量

  - 一个对象变量并没有实际包含一个对象，而仅仅是引用对象
  - `Date dealine = new Date();`表达式new Date()构造了一个Date类型的对象，并且它的值是对新创造对象的引用
  - new操作符的返回值也是一个引用
  - java中必须使用clone方法获取对象的完整副本
  - 如果将一个方法应用于一个值为null对象上，那么就会产生运行错误。
  - 所有的java对象都存放在堆中，当一个对象包含另一个对象变量时，它只是包含另一个堆对象的指针

- LocalDate

  -  Date类：表示时间点

    LocalDate类：⽇历表示法表示⽇期

  - 静态工厂方法来构造LocalDate的对象

    ![image-20220427142150281](appendix\2. JAVASE_1面向对象\image-20220427142150281.png)

  - 使用方法

    ![image-20220427142207271](appendix\2. JAVASE_1面向对象\image-20220427142207271.png)

- 访问器⽅法：只访问对象⽽不修改对象的⽅法;（如plusDays返回⼀个新的对象，原对象还在）

  更改器⽅法：调⽤⽅法之后修改对象的内容



### 用户自定义类

主⼒类：通常没有main⽅法，却有⾃⼰的实例字段和实例⽅法;（例如：⾃定义User类）

⼀个源⽂件中只能有⼀个公共类，但是可以有任意数ᰁ的⾮公共类。







## 5. 继承和多态

![image-20220427135635871](appendix\2. JAVASE_1面向对象\image-20220427135635871.png)

#### 继承层次

- 由一个公共超类派生出来的所有类的集合是继承层次

- 在继承层次中，从某个特定的类到其祖先的路径是该类的继承链（子到父）
- java中不支持多继承，但可以通过接口来实现



#### 阻止继承（final）

- 基本类型：不可更改 常量

- 引用类型：不可指向新的引用，但对象状态可以改变

- 类：该类不可继承（确保他们不会再子类中改变语义）

- 方法：子类不能覆盖这个方法

  

#### 覆盖方法（重写）

- 使⽤ super 关键字可以调⽤⽗类⽅法，避免覆盖⽗类⽅法时调⽤⽗类⽅法造成不必要的递归 

- super 不是⼀个对象的引⽤，不能将super 赋给另⼀个对象变量

  

#### 子类重写父类方法需要注意：

- private方法不能被重写
- final方法不能被重写
- 子类所重写的方法的修饰符要>=父类
- 返回值要是父类的返回值或者是父类返回值的派生



#### 子类构造器

- super代用父类构造器

- 必须放在子类构造器的第一条

- 若子类构造器没有显示调用父类，这自动调用父类无参；若父类没有无参构造器，则在子类中必须显式定义调用父类的哪个构造器

- **构造方法不能被重写（override），但可以被重载（overload），可以通过参数列表进行区别**

  

#### this和super关键词

this关键词：

- 隐式参数的引用
- 调用该类的其他构造器

super关键字：

- 调用父类方法
- 调用父类构造器

**this可以作用当前对象的引用，但是super不能作为父类对象的引用**



## 6. 深拷贝、浅拷贝、引用拷贝

深拷贝：完全复制整个对象，包含这个对象所包含的内部对象

浅拷贝：会在堆上创建一个新的对象（区别于引用拷贝），如果眼对象内部的属性是引用类型，则会直接复制内部对象的引用地址，也就是说拷贝对象和原对象用同一个内部对象。

引用拷贝：两个不同的引用指向同一个对象

![image-20220426171507496](appendix\2. JAVASE_1面向对象\image-20220426171507496.png)





## 7. 理解方法调用

以调⽤ x.f(arg) 为例，隐式参数 x 为类 C 的⼀个对象： 

（1）编译器查看对象的声明类型和⽅法名

编译器查找 C 类中所有名为 f 的⽅法和⽗类中名为 f 且可访问的⽅法（⽗类 private ⽅法不可访问） 

此时，编译器知道所有可能被调⽤的候选⽅法 

（2）编译器确定⽅法调⽤中提供的参数类型

**重载解析：** 在所有名为 f 的⽅法中，找到⼀个与所提供参数类型完全匹配的⽅法 

此时，编译器已经知道需要调⽤的⽅法名字和参数类型 

（3）**静态绑定**(编译阶段绑定)

如果是 private ⽅法、static ⽅法、final ⽅法或者构造器， 那么编译器将可以准确地知道应该调⽤哪个⽅法。

此时调⽤⽅法只⽤考虑 x 的类型（若在类 C 中找不到 f ⽅法，则向其⽗类中找），不需要考虑类 C 的⼦类（因为这⼏种修饰的⽅法都不能被继承）

只有静态绑定成功，即编译通过了，才能进⼊运⾏阶段 

（4）**动态绑定**(运⾏阶段绑定)

如果调⽤的⽅法依赖于隐式参数的实际类型，那么必须在运⾏时使⽤动态绑定。 

虚拟机必须调⽤与 x 所引⽤对象的实际类型对应的那个⽅法 

例如：x的实际类型是 D，它 是C类的⼦类。

如果：D 类定义了⽅法 f(String) ，就直接调⽤它；

否则：将在 D 类的超类中寻找 f(String) ，以此类推。 

![image-20220427132207780](appendix\2. JAVASE_1面向对象\image-20220427132207780.png)



## 8. 类型转换

- 向上转型（upcasting），自动类型转换

  子类型-》父类型

- 向下转型（downcasting），强制类型转换

  父类型-》子类型

- 注意：

  只能在继承层次内进⾏类型转换

  在将超类转换成⼦类之前，应该使⽤ instanceof 进⾏检查



## 9. 接口

接口相当于一个抽象方法，不能被继承，只能被实现

多种类可以实现，重写同一个接口

好处：多态，可以被不同的类实现，一个类可以实现很多接口





## 10.方法

### 静态方法为什么不能调用非静态成员

静态方法在类加载的时候就分配内存, 非静态成员在之后实例化才会被分配内存



静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作



### 静态方法和实例方法有何不同

**1、调用方式**

**调用静态方法可以无需创建对象**

2、**访问类成员是否存在限制**

静态方法在访问本类的成员时，只允许访问静态成员



### 重载和重写的区别

**重载**：方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重写**：运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。构造方法无法被重写。



**方法的重写要遵循“两同两小一大”**

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。



| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |



### 什么是可变长参数？

```java
public static void method2(String arg1, String... args) {
   //......
}
```

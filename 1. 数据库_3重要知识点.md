# 重要知识点

## 1. MySQL索引

B树

B+树

hashMap

先去补一下数据结构再看这个



## 2. MySQL三大日志

MySQL日志：错误日志、查询日志、慢查询日志、**事务日志**（redolog 重做日志）、**二进制日志**（binlog 归档日志）

![image-20220418142642796](appendix\1. 数据库_3重要知识点\image-20220418142642796.png)



### 2.1 redo log

redo log是InnoDB存储引擎独有的，让mysql有了崩溃恢复能力，比如MySQL实例挂了，重启时，InnoDB会使用redo log回复数据，保证数据的**持久性**。

![image-20220418143218901](appendix\1. 数据库_3重要知识点\image-20220418143218901.png)

#### 2.1.1 写入机制

1. mysql的数据以 `页` 为单位，每查询一条记录，会从硬盘把一 `页` 的数据加载出来，存入`Buffer Pool`中;

2. 后续的查询都是先从`Buffer Pool`中找，如果没有命中再去硬盘加载，减少硬盘的I/O开销；更新表数据的时候，也是如此，发现`Buffer Pool`中存在要更新的数据，就直接在`Buffer Pool`中更新；

3. 再把“在某个数据页上做了什么修改”记录(`redo log 记录`)到重做日志缓存中`redo log buffer`；

4. 从`redo log buffer`中刷盘到`redo log `文件中。

   ![image-20220418151431936](appendix\1. 数据库_3重要知识点\image-20220418151431936.png)



#### 2.1.2 刷盘时机

（写入机制的一部分内容）

理想情况下，事务一提交就会进行刷盘操作，但可以根据需求来调整策略



##### 2.1.2.1 概述

InnoDB为`redo log`提供三种策略：（对应参数`innodb_flush_log_at_trx_commit`）

- 0：事务提交不刷盘
- 1：事务提交刷盘（默认）
- 2：事务提交把`redo log buffer`内容写入`page cache`（系统的页缓存）

另外，InnoDB存储引擎有一个后台线程，每隔`1s`，就会把`redo log buffer`的内容写入到`page cache`，然后调用`fsync`刷盘。

![image-20220418152048847](appendix\1. 数据库_3重要知识点\image-20220418152048847.png)



##### 2.1.2.2 innodb_flush_log_at_trx_commit=0

如果MySQL挂了或者系统宕机，会有1秒数据的丢失

![image-20220418152622457](appendix\1. 数据库_3重要知识点\image-20220418152622457.png)

##### 2.1.2.3 innodb_flush_log_at_trx_commit=1

如果MySQL挂了或者系统宕机，不会有数据的丢失

![image-20220418152757324](appendix\1. 数据库_3重要知识点\image-20220418152757324.png)



##### 2.1.2.4 innodb_flush_log_at_trx_commit=2

如果MySQL挂了，不会有数据的丢失；

如果系统宕机，会有1秒数据的丢失

![image-20220418152908043](appendix\1. 数据库_3重要知识点\image-20220418152908043.png)



#### 2.1.3 日志文件组

##### 2.1.3.1 存在形式

硬盘上的`redo log `是以`日志文件组`形式存在，采用**环形数组**的方式存储

![image-20220418153304230](appendix\1. 数据库_3重要知识点\image-20220418153304230.png)

##### 2.1.3.2 重要属性

其有两个重要属性:

- wirte pos：指向当前记录的位置，一边写一边后移
- checkpoint：指向当前可以擦除的位置（不是已经擦除的位置），一边写一边后移

每次刷盘`redo log 记录`到`日志文件组`时，`write pos`会后移

每次从MySQL加载`日志文件组`进行恢复时，会清空`redo log 记录`，并把`checkpoint`后移

`write pos` 和 `checkpoint` 之间的还空着的部分可以用来写入新的 `redo log记录`。

![image-20220418153813668](appendix\1. 数据库_3重要知识点\image-20220418153813668.png)

如果`checkpoint`追上`write pos`，则日志文件组满了，MySQL需要清空一些`redo log 记录`，推进`checkpoint`

![image-20220418154010719](appendix\1. 数据库_3重要知识点\image-20220418154010719.png)

#### 2.1.4 一些问题

- 什么是刷盘

  把数据写入磁盘，写入`redo.log`就是在刷盘，写入数据库也是在刷盘

- 为什么要写到`redo log buffer`中？而不是直接写到`redo.log`（这个）中，再放入硬盘？

  说到底`redo log`日志也是写到磁盘中的，也是写文件，速度会有影响，所以需要缓存（`redo log buffer`）。  

- 写入`redo log`中`redo log buffe`r会清空吧

  应该是

- **为什么不把每次修改后的数据页直接刷盘（写入数据库），而要写入redo.log?不都是刷盘吗**

  1. 直接刷盘耗时，性价比低。数据页的大小是16KB，可能就修改了数据页的几byte数据，没必要把整个数据页刷盘；

  2. 数据页刷盘是随机写。因为数据页的存放位置在硬盘的随机位置，但如果写redo.log，一行记录就占几十byte，而且是顺序写，刷盘速度远远大于数据页刷盘，所以用redo.log也可以让数据库的并发能力更强。

     > - 每条`redo记录`组成：表空间号+数据页号+偏移量+修改数据长度+具体修改的数据
     >
     > - 内存的数据也在一定时机也会刷盘

- 一个没有提交事务的`redo log记录`，也可能会刷盘吗

  是的。因为在事务执行时，`redo log 记录`写入`redo log buffer`，这些`redo log 记录`会被后台线程进行刷盘。除了后台线程每秒的轮询操作，当`redo log buffer`的大小即将到达`innodb_log_buffer_size`的一半的时候，后台线程也会主动刷盘。

  

#### 2.1.5 部分概念

- fsync函数：同步内存中所有已修改的文件数据到储存设备。  

- page cache : 文件系统缓存（与数据库无关，是电脑自己的缓存）



### 2.2 binlog

`binlog`是逻辑日志，记录语句原始逻辑。类似于“给 ID=2 这一行的 c 字段加 1”，属于`MySQL Server` 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志。`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据**一致性**。

`binlog`会记录所有涉及**更新数据**的逻辑操作，并且是顺序写。

![image-20220418160751091](appendix\1. 数据库_3重要知识点\image-20220418160751091.png)



#### 2.2.1 记录格式

##### 2.2.1.1 概述

`binlog` 日志有三种格式：（对应参数`binlog_format`）

- **statement**
- **row**
- **mixed**

以执行一条`update T set update_time=now() where id=1`的语句进行讲解

##### 2.2.1.2 statement

- 只记录`SQL`语句**原文逻辑语句**

![image-20220418160942567](appendix\1. 数据库_3重要知识点\image-20220418160942567.png)



##### 2.2.1.3 row

- 记录`SQL`语句**原文逻辑语句**；

  记录**操作的具体数据**

- 原因是为了解决“`update_time=now()`这里会获取当前系统时间，直接执行会导致与原库的**数据不一致**“的问题。

![image-20220418161210506](appendix\1. 数据库_3重要知识点\image-20220418161210506.png)



##### 2.2.1.4 mix

- 在statment和row中按需进行选择

  `MySQL`会判断这条`SQL`语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式；

  从而优化执行速度并减少容量



#### 2.2.2 写入机制

1. 事务执行过程中，先把日志记录写到`binlog cache`

2. 事务提交的时候，再把`binlog cache`写到`binlog`文件中

   

#### 2.2.3 刷盘时机

（写入机制的一部分）

![image-20220418161914705](appendix\1. 数据库_3重要知识点\image-20220418161914705.png)

注意：

- `write`：指把日志写入到文件系统的`page cache`，并没有数据持久化到磁盘

- `fsync`：把数据持久化到磁盘

  

##### 2.2.3.1 概述

`write`和`fsync`的时机是可以控制的：（对应参数`sync_binlog`）

- 0：事务提交都只`write`，由系统自行判断什么时候执行`fsync`。（默认）
- 1：提交事务都会执行`fsync`，就如同 **redo log 日志刷盘流程** 一样。
- N：每次提交事务都`write`，但累积`N`个事务后才`fsync`。（N>1）



##### 2.2.3.2 sync_binlog=0

如果MySQL挂了，没有数据的丢失

如果系统宕机，有数据的丢失

![image-20220418162728024](appendix\1. 数据库_3重要知识点\image-20220418162728024.png)



##### 2.2.3.3 sync_binlog=1

如果MySQL挂了或系统宕机，没有数据的丢失



##### 2.2.3.4 sync_binlog=N

如果MySQL挂了，没有数据丢失

如果系统宕机，有N个事务的`binlog`丢失

![image-20220418163026801](appendix\1. 数据库_3重要知识点\image-20220418163026801.png)



#### 2.2.4 `redo log`的两阶段提交

##### 2.2.4.1 使用原因

由于`redo log`与`binlog`的写入时机不一样，可能会导致两份日志之间的**逻辑不一致**，从而导致**数据的不一致**。

解释：

`redo log`（重做日志）让`InnoDB`存储引擎拥有了崩溃恢复能力。

`binlog`（归档日志）保证了`MySQL`集群架构的数据一致性。

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以**基本的事务**为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。

以下图为例：

![image-20220418164304718](appendix\1. 数据库_3重要知识点\image-20220418164304718.png)

由于`binlog`没写完就异常，这时候`binlog`里面没有对应的修改记录。因此，之后用`binlog`日志恢复数据时，就会少这一次更新，恢复出来的这一行`c`值是`0`，而原库因为`redo log`日志恢复，这一行`c`值是`1`，最终数据不一致。

![image-20220418164346475](appendix\1. 数据库_3重要知识点\image-20220418164346475.png)

为了解决两份日志之间的逻辑一致问题，`InnoDB`存储引擎使用**两阶段提交**方案。



##### 2.2.4.2 原理

将`redo log`的写入拆成了两个步骤`prepare`和`commit`，进行**两阶段提交**。

![image-20220418164626714](appendix\1. 数据库_3重要知识点\image-20220418164626714.png)



##### 2.2.4.3 发生异常分析

- 写入`binlog`时发生异常

  会回滚

  ![image-20220418164734308](appendix\1. 数据库_3重要知识点\image-20220418164734308.png)

- `redo log`设置`commit`阶段发生异常

  不会回滚，因为可以通过事务id找到对应的`binlog`，这是完整的

  ![image-20220418164749460](appendix\1. 数据库_3重要知识点\image-20220418164749460.png)



#### 2.2.5 一些问题

- 为什么需要`binlog cache`

  因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要**确保一次性写入**，所以系统会给每个线程分配一个块内存作为`binlog cache`。可以通过`binlog_cache_size`参数控制单个线程 `binlog cache` 大小，如果存储内容超过了这个参数，就要暂存到磁盘（`Swap`）。

- `binlog`应该只在数据更新的时候记录，查询不会产生`binlog`



### 2.3 undo log

`undo log`是为了保证事务的**原子性**，在异常发生的时候，对已经执行的操作进行回滚。

`undo log`相当于逻辑日志, 记录的是变化过程, 比如做一个删除`delete`, `undo log`记录`insert`, 反言之, 做`insert`操作, `undo log`记录`delete`, 这样在出问题时, 就可以直接运行`undo log`回滚到起始位置。



#### 2.3.1 概述

`undo log`产生时间：`undo log`在事务开始前产生;

`undo log`销毁时间：事务在提交后, 并不会立刻删除`undolog`, 因为这个过程中可能需要用到undolog, 比如MVCC多版本控制。InnoDB会将该事务对应的`undolog`入到`删除列表`中, 后面会通过**后台线程`purge thread`**进行回收处理。

`undo log`存储: `undo log`采用**段方式管理**和记录, 在InnoDB数据文件中包含一种`rollback segment`回滚段, 内部包含1024个`undolog segment`。



#### 2.3.2 作用

- 把所有没有`COMMIT`的事务回滚到事务开始之前的状态

- `rollback`

- 多版本并发控制(`MVCC`)：事务未提交前, `undo log`保存了**未提交前的版本数据**，`undo log`中数据可作为数据旧版本快照供其他并发事务进行快照读

  ![image-20220418165939625](appendix\1. 数据库_3重要知识点\image-20220418165939625.png)

  

  事务A手动开启事务, 执行更新, 首先会把更新命中的数据备份到`undo buffer`中

  在事务A还没有提交的时候，事务B手动开启事务, 执行查询操作, 会读取`undo log`日志数据返回, 进行快照读



#### 2.3.3 刷盘时机

回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。



### 2.4 总结

- `redo log`：记录的是**结果**，属于数据库

  `binlog`：记录的是**逻辑**，控制语句，属于MySQL Server层

  `undo log`：记录的也是逻辑       

- `binlog`应该只在数据更新的时候记录，查询不会产生`binlog`

- `redo log`保证事务的持久性

  `undo log`保证事务的原子性

  MySQL数据库的数据备份、主备、主主、主从离不开`binlog`，保证数据的一致性





## 3. MySQL事务隔离级别详解

### 3.1 定义和作用

- 逻辑上的一组操作，要么都执行，要么都不执行。（比如银行转账）

  ```sql
  start transaction;
  ..
  commit
  ```



### 3.2 事务特性

- 关系型数据库事务都有ACID的特性

  - 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

  - 一致性：执行事务前后，数据保持一致，比如A给B转账，A少B多；

  - 持久性：事务成功就持久化到数据库，失败就回滚；

  - 隔离性：事务之间各部影响

    

### 3.3 事务实现原理

以mysql innodb为例

- 通过redo log保证事务的持久性
- 通过undo log保证事务的原子性
- 通过锁机制、mvcc保证事务的隔离性
- binlog保证事务的一致性
- 从而保证一致性



### 3.4 并发事务带来的问题

- 脏读：一个事务访问了另一个事务的未提交的数据

- 丢失修改：一个事务修改了另一个事务未提交数据，导致之前的事务修改操作失败

- 不可重复读：一个事务A在未结束的情况下多次读同一数据，由于其他事务可能会修改数据，导致了A可能读取的数据会不一样

- 幻读：一个事务A读取数据时，另一个事务插入了数据

  > 不可重复度和幻读的区别：不可重复读是发现已有数据的值被修改，幻读是发现记录增多或减少



### 3.5 事务隔离级别

- READ-UNCOMMITTED(读取未提交)

  最低的隔离级别，可能会导致脏读、幻读、不可重复读

- REAS-COMMITTED(读取已提交)

  可以阻止脏读，幻读、不可重复读还会发生

- REPEATABLE-READ(可重复读)

  多次读取结果一致，可以阻止脏读、不可重复读、但还会导致幻读

- SERIALIZABLE(可串性化)

  最高隔离级别，逐个执行，可以阻止脏读、不可重复读、幻读

  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |
  | :--------------: | :--: | :--------: | :--: |
  | READ-UNCOMMITTED |  √   |     √      |  √   |
  |  READ-COMMITTED  |  ×   |     √      |  √   |
  | REPEATABLE-READ  |  ×   |     ×      |  √   |
  |   SERIALIZABLE   |  ×   |     ×      |  ×   |



### 3.6 MySQL默认隔离级别

```sql
-- 查看命令
SELECT @@transaction_isolation;
-- 结果
REPEATABLE-READ（可重读）
```

- 大部分数据库系统的隔离级别是**读取已提交**，但InnoDB默认的**可重复读**并不会有性能损失，其在分布式事务的情况下用到**可串行化**隔离级别。
- Mysql解决幻读的方法：
  - 事务隔离级别调整为SERIALIZABLE
  - 在可重复读的情况下，给事务添加表锁
  - 在可重复读的情况下，给事务添加Next-Key Locks（行锁+间隙锁【对一定范围内的数据进行加锁】）



## 4. SQL语句在MySQL中的执行过程

### 4.1 MySQL基本架构

MySQL主要分为**Server层**和**存储引擎层**

![image-20220418142642796](appendix\1. 数据库_3重要知识点\image-20220418142642796.png)

- **Server 层**：主要包括**连接器**、**查询缓存**、**分析器**、**优化器**、**执行器**等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。

- **存储引擎**： **主要负责数据的存储和读取**，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

  ![image-20220418183630011](appendix\1. 数据库_3重要知识点\image-20220418183630011.png)

#### 4.1.1 Server层组件

- 连接器

  **身份认证和权限**相关工作（登录MySQL）。进行用户的身份认证，包括校验账户密码。权限等操作。如果用户账户密码已通过，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。

- 查询缓存

  执行查询语句，会先查缓存（8.0版本之后移除了，因为不实用）。缓存所执行的 SELECT 语句以及该语句的结果集。

- 分析器

  词法分析+语法分析。说白了就是看你要干嘛，再检查语法是否正确。

- 优化器

  按照MySQL认为最优的方案执行。比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

- 执行器

  执行前会**校验该用户**有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。



### 4.2 执行过程

#### 4.2.1 查询（select）

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

- 检查语句是否有权限，没有则返回错误信息，有则查缓存，如果有直接缓存，没有执行下一步
- 通过词法分析，提取sql的关键元素，比如表、列、查询条件；再判断有无语法错误
- 优化器进行确定执行方案，比如先查18还是张三
- 用户权限校验，没有权限返回错误信息，有则调用引擎接口，返回引擎的执行结果



#### 4.2.2 更新（update delete insert）

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

- 先查询张三这条数据，有缓存则用
- 查到查询的语句，将age改为19
- 调用引擎API接口，写入这一行数据。同时记录redo log（prepare），并告诉执行器，执行完成，随时可提交
- 执行器收到通知后记录binlog，然后调用引擎接口，提交事务，提交binlog，提交redo log（commit）
- 更新完成



### 4.3 总结

- 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等

- 查询语句的执行流程如下：

  权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎

- 更新语句的执行流程如下：

  分析器---->权限校验---->执行器--->引擎-->提交事务--->提交redo log(prepare 状态)--->提交binlog--->提交redo log(commit状态）





## 5. InnoDB存储引擎对MVCC的实现





## 6. MySQL中的隐式转换造成的索引失效

数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。本文讲得是**隐式转换造成的索引失效**。



### 6.1 测试

```sql
1: SELECT * FROM `test1` WHERE num1 = 10000;
2: SELECT * FROM `test1` WHERE num1 = '10000';
3: SELECT * FROM `test1` WHERE num2 = 10000;
4: SELECT * FROM `test1` WHERE num2 = '10000';
```

表共1000 万条数据，其中`num1`是`int`,`num2`是`varchar`



### 6.2 执行结果

其中 124 三条 SQL 基本都是瞬间出结果，但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。



### 6.3 结果分析

- 查看执行计划数据

  ![image-20220418194002743](appendix\1. 数据库_3重要知识点\image-20220418194002743.png)

  124 三条 SQL 都能使用到索引，连接类型都为`ref`，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，`rows`直接到达 1000 万了，所以性能差别才那么大。

- 结果分析

  当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。

  2.3两条发生隐式转换，左右两边都会转换为浮点数再进行比较，左边是带索引的

  ```sql
  第2条：(int-varchar) 。左边int转换为浮点数还是`10000`，右边varchar`'10000'`，转换为浮点数也是`10000`。两边的转换结果都是**唯一确定**的，所以不影响使用索引。
  
  第3条：(varchar-int) 。左边varchar转为浮点数`10000`，但不唯一，因为`10000a`,`010000`,`10000`都会转为浮点数`10000`，所以索引失效了。
  ```



### 6.4 总结

- 当操作符**左右两边的数据类型不一致**时，会发生**隐式转换**
- 当 where 查询操作符**左边为数值类型**时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。
- 当 where 查询操作符**左边为字符类型**时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。
- 字符串转换为数值类型时，非数字开头的字符串会转化为`0`，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。

# 常考面试题

## 1. **慢查询是什么？怎么解决？**

慢查询：

设置sql指定超时时间，超过这个时间的sql语句被称为慢查询

long_query_time：默认10s

如何解决：

- 运行语句，找到慢查询的sql
- 查询区分度最高的字段
- 通过explain，显式mysql如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
- order by limit形式的sql语句，让排序的表优先查
- 考虑简历索引原则
- 了解业务使用场景



## 2. **子查询和连接查询是什么？**

子查询：

子查询又称内查询，在主查询之前一次执行完成，可能会多次遍历数据。

其结果被主查询使用。

将查询操作嵌套在另一个查询操作中。

先执行子查询，再执行外查询。



连接查询：

https://blog.csdn.net/Ber_Bai/article/details/118029011#inner_join_1

将表连接后再进行查询，仅遍历一次。

又分为内连接（又称等值连接，【自然连接去掉重复列的等值连接】）、外连接（左外、右外、全外【mysql中无】）、交叉连接（不带where子句 笛卡尔乘积）、自连接

![image-20220420135027868](appendix\1.数据库_5常考面试题\image-20220420135027868.png)![image-20220420135047666](appendix\1.数据库_5常考面试题\image-20220420135047666.png) ![image-20220420135104395](appendix\1.数据库_5常考面试题\image-20220420135104395.png)



选择：

连接查询的效率更高，因为子查询会多次遍历数据，而连接查询值遍历一次，但是数据量小的情况下，自查询更加容易控制。





## **3. Mysql中的临时表**

- 内部临时表：

  - 一类是information_schema中的临时表

  - 一类是会话查询时，`group by`,`distinct`,`union`等语句，含有“using temporary”，辅助sql执行

    - 使用场景：

      取两个子查询结果的并集，重复的数据只保留一行，通过建立一个带主键的临时表，就可以解决“去重”问题；

      对于group by而言，我们首先需要统计每个值出现的数目，这就需要借助临时表来快速定位，如果不存在，则插入一条记录，如果存在，并累加计数，所以看到了"Using temporary"；

      

- 外部临时表：

通过语句`create temporary table`，可以指定临时表的内存引擎

​	创建一个 frm 文件保存表结构定义，还要有地方保存表数据



临时表和普通表的说明：

在服务器重启之后，所有临时表都会被销毁，会话断开后无效

临时表示进程独占的，当前进程创建的临时表，其他进程是查不到的



索引可以帮助服务器避免进行排序和分组,以及避免创建临时表(B-Tree索引是有序的，可以用于
ORDER BY和GROUP BY操作。**临时表主要是在排序和分组过程中创建,不需要排序和分组,也就不需要创建临时表)**



## 4. **mysql的日志文件有哪些**

MySQL日志：

错误日志、查询日志、慢查询日志、**事务日志**（redolog 重做日志）、**二进制日志**（binlog 归档日志）、中继日志（relay log） 

- redo log：(持久性、崩溃恢复)

  redo log是InnoDB**存储引擎**独有的，让mysql有了崩溃恢复能力，比如MySQL实例挂了，重启时，InnoDB会使用redo log回复数据，保证数据的**持久性**。

- undolog:（原子性、MVCC）

  `undo log`是**Mysql存储引擎**InnoDB的事物日志，是为了保证事务的**原子性**，`undo log`相当于逻辑日志, 记录的是变化过程, 比如做一个删除`delete`, `undo log`记录`insert`, 反言之, 做`insert`操作, `undo log`记录`delete`。常用于

  - 在异常发生的时候，对已经执行的操作进行回滚。
  - 多版本并发控制(`MVCC`)：事务未提交前, `undo log`保存了**未提交前的版本数据**，`undo log`中数据可作为数据旧版本快照供其他并发事务进行快照读

- binlog :（一致性、主从同步）

  bin log是数据库**server层日志**，和存储引擎无关，以二进制形式存储在磁盘中的逻辑日志，记录了所有DDL和DML操作(不包括select和show)。不管用什么存储引擎，只要发生了**表数据更新**，都会产生 `binlog` 日志。`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据**一致性**。

  `binlog`会记录所有涉及**更新数据**的逻辑操作，并且是顺序写。

- relay log：（中转、主从复制）

  relay log和bin log具有相同的格式，上面主从复制流程页提到了relay log,其主要作用起到一个中转作用。

- error log

  错误日志记录mysql服务**每次启动和停止的时间以及诊断和出错信息**，默认开启，可通过 show variables like ‘log_error’ 查找存放路径。

- 查询日志

  一般查询日志用来记录用户的所有操作，包括客户端何时连接的服务器、客户端发送的所有sql以及其他等事情。处于性能考虑，该日志功能默认也是关闭的。

- 慢查询日志

  慢查询日志用于记录在mysql执行过程超过指定时间的查询语句，处于性能考虑，一般只有在排查慢查询、调试参数时候才会开启，默认情况下时关闭的，默认时间时10s



bin log 和 redo log区别：

- 层次不同：redo log是基于innodb存储引擎的，而bin log 是基于数据库服务层实现的，所以mysql数据库中任何存储引擎对数据库进行修改都会产生bin log
- 作用不同：redo log 用于碰撞恢复(crash recovery),保证**mysql宕机不会影响持久性**；而bin log 用于**时间点恢复数据**(point-in-time-recovery),保证服务器可以基于时间点恢复数据以及**主从复制**
- 内容不同：redo log是物理日志，记录的是做了什么修改，**结果**；bin log内容是二进制的，记录的是**语句原始逻辑**
- 写入方式不同：redo log采用**循环写入**的方式，bin log采用**顺序写**（追加）的方式
- 刷盘时机不同:redo log在**事务开始时**即开始写入，而bin log在**事务提交**才写入



## 5. MySQL日志两阶段提交

为了让两份日志之间的逻辑一致。由于`redo log`与`binlog`的写入时机不一样，可能会导致两份日志之间的**逻辑不一致**，从而导致**数据的不一致**。redo log在**事务开始时**即开始写入，而bin log在**事务提交**才写入。

将`redo log`的写入拆成了两个步骤`prepare`和`commit`，进行**两阶段提交**。

![image-20220418164749460](F:\xrz\桌面\BasicKnowledge\appendix\1. 数据库_5常考面试题\image-20220418164749460.png)

![image-20220420151448672](appendix\1. 数据库_5常考面试题\image-20220420151448672.png)



## 6. **mysql几个基本索引类型有哪些？为什么对某个字段建立索引。**

![image-20220420151657768](appendix\1. 数据库_5常考面试题\image-20220420151657768.png)



主键索引（聚集索引）：数据表的主键列使用的就是主键索引。

二级索引（非聚集索引）：二级索引又称为辅助索引，是因为**二级索引的叶子节点存储的数据是主键**。也就是说，通过二级索引，可以**定位主键的位置**。**唯一索引，普通索引，前缀索引等索引属于二级索引。**

- 唯一索引：数据不能重复，可以为NULL，可有多个。（目的：大部分时候都是为了该属性列的**数据的唯一性**，而不是为了查询效率）
- 普通索引：数据可以重复，可以为NULL，可有多个。（目的：快速查询数据）
- 前缀索引：只适用于字符串，对文本前几个字符创建索引。
- 全文索引：（目的：检索大文本数据中的关键字信息）



聚集索引即**索引结构和数据**一起存放的索引。主键索引属于聚集索引。需要排序，更新代价大，因为有数据。

非聚集索引即**索引结构和数据分开存放的索引。二级索引属于非聚集索引。**可能会回表

​	- 覆盖索引即需要查询的字段正好是索引的字段。非聚集索引无需回表

联合索引使用表中的**多个字段创建索引**，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。

	- 最左前缀匹配原则，从**左到右**依次到**查询条件**中去匹配，可以将区分度高的字段放在最左边，这也可以过滤更多数据。



为什么对某个字段建立索引？

用于快速查询和检索数据的数据结构。索引是为了快速查找数据，就跟⼀本书的⽬录⼀样。在⽬录中检索到具体章节的⻚码，然后直接跳转，就相当于根据索引快速找到数据在磁盘上的地址，然后去读取数据。 对于**中到大型**表索引都是非常有效的。

MySQL数据库索引采⽤的是B+Tree结构，在B-Tree结构上做了优化改造

- 索引能够提高数据检索的效率，降低数据库的IO成本，将随机io变成顺序io

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，创建唯一索引

- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间,因为本身有序

- 加速两个表之间的连接，一般是在外键上创建索引，实现数据参考完整性上很有用
- 通过使用索引，可以再查询单饿过程中使用优化隐藏器，提高系统的性能



## 7. **索引什么？为什么用索引?索引使用什么数据结构?b+树是什么？b+树叶子节点链表是双向链表还是单向？**

- 索引是一种用于快速查询和检索数据的数据结构。

  索引是为了快速查找数据，就跟⼀本书的⽬录⼀样。在⽬录中检索到具体章节的⻚码，然后直接跳转，就相当于根据索引快速找到数据在磁盘上的地址，然后去读取数据。 

  MySQL数据库索引采⽤的是B+Tree结构，在B-Tree结构上做了优化改造

- 原因见上题

- InnoDB使用的数据结构是B+树。

- B+树是多路平衡查找树。

  B+树常用于数据库和操作系统文件系统的用于查找的数据结构

  B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树特点： 

  1. ⾮叶⼦节点不存储data数据，只存储索引值，这样便于存储更多的索引值 

  2. 叶⼦节点包含了所有的索引值和data数据 

  3. 叶⼦节点⽤指针连接，提⾼区间的访问性能  

- 单向。B+树中，**有一个指针指向关键字最小的叶子结点，所有叶子结点链接成一个单链表**。



## 8. **聚簇索引和非聚簇索引是什么？唯一索引是聚簇索引吗，主键索引是聚簇索引吗**

- 聚集索引即**索引结构和数据**一起存放的索引。主键索引属于聚集索引。

  因为 B+树是多路平衡树，如果索引的数据**不是有序的，那么就需要在插入时排序**；更新代价大，因为有数据。

  

  非聚集索引即**索引结构和数据分开存放的索引。二级索引属于非聚集索引。**更新代价小；可能会回表二次查询。

  覆盖索引即需要查询的字段正好是索引的字段，则非聚集索引无需回表。

- 在一些情况下是，簇族索引的选择顺序是主键，唯一索引，隐藏列。默认是主键，如果不设置主键就是表里的一个唯一索引，如果唯一索引也没有设置，是mysql在每行后加的三列之一的一个自增列，用来做簇族，就是聚簇索引。

  

## 9. 建立了索引但是索引无效是为什么？

- **隐式转换造成的索引失效**。

```sql
(varchar-int) 。左边varchar转为浮点数`10000`，但不唯一，因为`10000a`,`010000`,`10000`都会转为浮点数`10000`，所以索引失效了。
```

- 没有查询条件，或者查询条件没有建立索引

- 在查询条件上没有使用引导列，尽量使用覆盖索引减少使用select *

- 对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等)

- 模糊查询，like "%_" 百分号在前。可以用覆盖索引，也就是引导列

- 单独引用复合索引里非第一位置的索引列

- not in ,not exist，使用 is null 或者 is not null 也不能使用索引

- 少用or，用它来连接索引会失效

- 存储引擎不能使用索引**范围条件**右边的列、比如

  ```sql
  select * from myTest  where a=3 and b>7 and c=3; ---- b范围值，断点，阻塞了c的索引
  ```

- 索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引





最左匹配原则：最左优先，以最左边的为起点任何连续的索引都能匹配上，如不连续，则匹配不上； 索引失效在以下情况： 

- 不满⾜最左【前缀】匹配规则 

- 在索引列上做任何操作如计算、函数、（⼿动或⾃动）类型转换等操作，会导致索引失效⽽进⾏全表扫描 

- 使⽤不等于（!= 、<>） 

- like 中以通配符开头(’%abc’) 

- 字符串不加单引号索引失效 

- or 连接索引失效

## 10.  事务的ACID特性是什么？

关系型数据库事务都有ACID的特性

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

- 一致性：执行事务前后，数据保持一致，比如A给B转账，A少B多；

- 持久性：事务成功就持久化到数据库，失败就回滚；

- 隔离性：事务之间各不影响

  

- 通过redo log保证事务的持久性
- 通过undo log保证事务的原子性
- 通过锁机制、mvcc保证事务的隔离性
- binlog保证事务的一致性
- 从而保证一致性



## 11. 事务的隔离的级别

- READ-UNCOMMITTED(读取未提交)

  最低的隔离级别，可能会导致脏读、幻读、不可重复读

- REAS-COMMITTED(读取已提交)

  可以阻止脏读，幻读、不可重复读还会发生

- REPEATABLE-READ(可重复读)

  多次读取结果一致，可以阻止脏读、不可重复读、但还会导致幻读

- SERIALIZABLE(可串性化)

  最高隔离级别，逐个执行，可以阻止脏读、不可重复读、幻读

  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |
  | :--------------: | :--: | :--------: | :--: |
  | READ-UNCOMMITTED |  √   |     √      |  √   |
  |  READ-COMMITTED  |  ×   |     √      |  √   |
  | REPEATABLE-READ  |  ×   |     ×      |  √   |
  |   SERIALIZABLE   |  ×   |     ×      |  ×   |





- 脏读：一个事务访问了另一个事务的未提交的数据

- 丢失修改：一个事务修改了另一个事务未提交数据，导致之前的事务修改操作失败

- 不可重复读：一个事务A在未结束的情况下多次读同一数据，由于其他事务可能会修改数据，导致了A可能读取的数据会不一样

- 幻读：一个事务A读取数据时，另一个事务插入了数据

  > 不可重复度和幻读的区别：不可重复读是发现已有数据的值被修改，幻读是发现记录增多或减少





## 12. 可重复读是什么？

事务的隔离级别，REPEATABLE-READ(可重复读)

一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以阻止脏读、不可重复读、但还会导致幻读。



- 快照读的情况下：

  rr不能更新事务内的 up_limit_id ,⽽ rc 每次会把 up_limit_id 更新为快照读之前最新已提交事务的 transaction id,则 rc 不能可重复读 

- 当前读的情况下：

  rr 是利⽤ record lock+gap lock来实现的,⽽ rc 没有 gap,所以 rc 不能重复读



在读提交（RC），可重复读（RR）两个不同的事务的隔离级别下，快照读有什么不同呢？

- 事务总能够读取到，⾃⼰写⼊（update /insert /delete）的⾏记录 

- RC 下，快照读总是能读到**最新的⾏数据快照**，当然，必须是已提交事务写⼊的。 

- RR 下，某个事务**⾸次 read 记录的时间为 T**，未来不会读取到 T 时间之后已提交事务写⼊的记录，以保证连续相同的 read 读到相同的结果集 



## 13. 事务的原子性怎么实现的？

通过undo log保证事务的原子性。在异常发生的时候，对已经执行的操作，但没有提交的事务进行回滚。

`undo log`相当于逻辑日志, 记录的是变化过程, 比如做一个删除`delete`, `undo log`记录`insert`, 反言之, 做`insert`操作, `undo log`记录`delete`, 这样在出问题时, 就可以直接运行`undo log`回滚到起始位置。



`undo log`产生时间：`undo log`在事务开始前产生;

`undo log`销毁时间：事务在提交后, 并不会立刻删除`undolog`, 因为这个过程中可能需要用到undolog, 比如MVCC多版本控制。InnoDB会将该事务对应的`undolog`入到`删除列表`中, 后面会通过**后台线程`purge thread`**进行回收处理。

`undo log`存储: `undo log`采用**段方式管理**和记录, 在InnoDB数据文件中包含一种`rollback segment`回滚段, 内部包含1024个`undolog segment`。



## 14. delete和drop的区别？

- 用法区别

  - drop会删除表结构
  - delete会删除表数据，不加where和truncate差不多。
  - truncate清空数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用（说白了就是删除表再创建）

- 属于不同的数据库语言

  - drop和truncate属于DDL(数据定义)，立即生效不能回滚。DDL 语句更多的被数据库管理员（DBA）所使用。
  - delete属于DML(数据操作)，可以回滚。不涉及到表的定义、结构的修改，更不会涉及到其他对象。

- 执行速度

  drop > truncate > delete

  因为Delete需要生成日志

  truncate需要重置





## 15. 写SQL

- 有一个user表，包括uid，name字段

  有一个record表，包括id，uid， create_date字段

  根据name查询最近10条的record记录。

  ```sql
  select * 
  from record
  where uid in (
  	select uid 
      from user
      where name = "name"
  )
  order by create_data
  limit 10
  ```

- 当表A的id和表B的id相同时，将表A的某个字段x的值赋给表B的某个字段的值 

  ```sql
  update A set A.KZXM = (
       select B.xm 
       from  B 
       where A.ID=B.ID 
       limit 1
  )
  ```

- 表grade，有三列，name、subject、score，找到：语文这科目，姓张的同学中成绩最好的三个人的姓名和分数

  ```sql
  select name,score
  from grade
  where subject="语文" and name like "张%"
  order by score desc
  limit 3
  ```



## 16. 索引失效和最左匹配原则

最左匹配原则：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （***a,b,c***）。 可以支持***a | a,b| a,b,c*** 3种组合进行查找，但不支持 b,c进行查找 。当最左侧字段是常量引用时，索引就十分有效。

- 能使用哪个索引？

  ```sql
  index1(A,B)  
  
  index2(A,C)
  
  select * from table where A = xxx and B > xxx and C = xxx;
  ```

  第一个，因为第二个会被阻断掉，最左匹配原则

- 建立索引，写sql语句，时间精确到年月日

  查找一种商品的所有信息 	

  ```sql
  select * from table where product_name = "xxxxx"';
  ```

  查找某个时间所有商品  

  ```sql
  select product_name from table where date = "xxxx";
  ```

  查找这个商品最近三十天的信息 , 只有一个范围查询，且后面没有字段，联合索引不会失效。

  （存储引擎不能使用索引**范围条件**右边的列）

  ```sql
  select * from table where product_name = "xxxx" and date > 30;
  ```

  怎么建立索引？能建立一个联合索引不？

  创建商品名和时间的联合索引、时间索引 

  创建创建时间和商品名的联合索引、商品名索引

  答：

  不能只建一个联合索引，还需要一个普通索引。

  索引不是越大越好（选数据空间占用小的好维护，看商品名和时间谁占的空间更小，如果时间精确到年月日可能占用空间更大，则选②）



## 17. 关键词及执行顺序

关键字		解释					执行顺序			备注

from 		表					第一步

join			连接类型				第二步		表1 join 表2 on 连接条件															（xxx==xxx）

on 			连接条件				第三步

where 		筛选条件				第四步		对表中字段进行操作

group by 		分组列表				第五步		group by 列名

having 		分组后的筛选条件		第六步		对已筛选的组/列、聚合函数进行操作

select 		查询列表（字段）		第七步

order by		 排序列表				第八步		order by 列名

​                                            默认升序asc，降序desc

limit			 偏移 ，条目数			第九步		limit 5 ；前五条记录

​                                            limit 5，10； 6-15行记录

​                                            limit 5，-1；6-最后一行记录

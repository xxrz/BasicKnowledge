# MySQL

## 1.1 定义

MySQL是建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。所以**MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息**。



## 1.2 存储引擎

```sql
-- 查看mysql全部存储引擎
show engines;
```

### 1.2.1 MyISAM 和 InnoDB对比

**1.是否支持行级锁**

MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

**2.是否支持事务**

MyISAM 不提供事务支持。

InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。

**3.是否支持外键**

MyISAM 不支持，而 InnoDB 支持。

🌈 拓展一下：

一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据项目来决定。

**4.是否支持数据库异常崩溃后的安全恢复**

MyISAM 不支持，而 InnoDB 支持。

使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。

🌈 拓展一下：

- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的**隔离性**（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

**5.是否支持 MVCC**

MyISAM 不支持，而 InnoDB 支持。

MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。



### 1.2.2 关于 MyISAM 和 InnoDB 的选择问题

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。

因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。



### 1.2.3 锁机制与 InnoDB 锁算法

**MyISAM 和 InnoDB 存储引擎使用的锁：**

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB 存储引擎的锁的算法有三种：**

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身



## 1.3 查询缓存

执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。

```sql
-- 开启缓存
set global  query_cache_type=1;
set global  query_cache_size=600000;
```

### 1.3.1 缓存不命中的情况

- 任何两个查询在任何字符上有不同
- 查询中包含用户自定义函数、存储函数、用户变量、临时表、MySQL系统表
- 表发生变化



### 1.3.2 注意

- 缓存岁可以提升数据库查询效率，但是也会带来额外开销，失效后还要销毁

- 可以合理控制缓存空间大小

- 可以控制某个查询语句是否缓存（局部）

  ```sql
  select sql_no_cache count(*) from usr;
  ```



## 1.4 事务

### 1.4.1 定义和作用

- 逻辑上的一组操作，要么都执行，要么都不执行。（比如银行转账）

  ```sql
  start transaction;
  ..
  commit
  ```



### 1.4.2 事务特性

- 关系型数据库事务都有ACID的特性

  - 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

  - 一致性：执行事务前后，数据保持一致；

  - 隔离性

  - 持久性

    

### 1.4.3 事务实现原理

以mysql innodb为例

- 通过redo log保证事务的持久性
- 通过undo log保证事务的原子性
- 通过锁机制、mvcc保证事务的隔离性
- 从而保证一致性



### 1.4.4 并发事务带来的问题

- 脏读：一个事务访问了另一个事务的未提交的数据

- 丢失修改：一个事务修改了另一个事务未提交数据，导致之前的事务修改操作失败

- 不可重复读：一个事务A在未结束的情况下多次读同一数据，由于其他事务可能会修改数据，导致了A可能读取的数据会不一样

- 幻读：一个事务A读取数据时，另一个事务插入了数据

  > 不可重复度和幻读的区别：不可重复读是发现已有数据的值被修改，幻读是发现记录增多或减少



### 1.4.5 事务隔离级别

- READ-UNCOMMITTED(读取未提交)

  最低的隔离级别，可能会导致脏读、幻读、不可重复读

- REAS-COMMITTED(读取已提交)

  可以阻止脏读，幻读、不可重复读还会发生

- REPEATABLE-READ(可重复读)

  多次读取结果一致，可以阻止脏读、不可重复读、但还会导致幻读

- SERIALIZABLE(可串性化)、

  最高隔离级别，逐个执行，可以阻止脏读、不可重复读、幻读

  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |
  | :--------------: | :--: | :--------: | :--: |
  | READ-UNCOMMITTED |  √   |     √      |  √   |
  |  READ-COMMITTED  |  ×   |     √      |  √   |
  | REPEATABLE-READ  |  ×   |     ×      |  √   |
  |   SERIALIZABLE   |  ×   |     ×      |  ×   |



### 1.4.6 MySQL默认隔离级别

```sql
-- 查看命令
SELECT @@transaction_isolation;
-- 结果
REPEATABLE-READ（可重读）
```

- 大部分数据库系统的隔离级别是**读取已提交**，但InnoDB默认的**可重复读**并不会有性能损失，其在分布式事务的情况下用到**可串行化**隔离级别。
- Mysql为了避免幻读，需要使用加锁读来保证，机制是Next-Key Locks





## 1.5 一些规范和注意点

时间相关的：

- **经常会有人用字符串存储日期型的数据（不正确的做法）**

  字符串占用空间大，效率低（字符逐个比较），无法使用日期相关API进行计算和比较

- 通常**首选 Timestamp**，而不是**DateTime**

  - DateTime没有时区，Timestamp与时区相关，在不同时区，查询到同一条记录此字段的值会不一样，随机应变
  - DateTime 类型耗费空间更大(8字节)，Timestamp(4字节)，范围是
    - DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
    - Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

- 如果选择时间戳（与时区无关）进行存储，只有在显示给用户的时候，才转换为字符串格式的本地时间，缺点是数据可读性差

  ![image-20220418192842409](appendix\1. 数据库_2MySQL\image-20220418192842409.png)



与时间不相关的：

- 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀
- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）
- 所有表必须使用 Innodb 存储引擎
- 字符集使用UTF-8
- **对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储**
- VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。**过大的长度会消耗更多的内存**
- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
- 使用最频繁的列放到联合索引的左侧
- 对应同一列进行 or 判断时，使用 in 代替 or


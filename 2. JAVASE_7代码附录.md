# 代码附录

## 迭代器

```java
Iterator<String> it = strList.iterator();
        while (it.hasNext()) {
            String str = (String) it.next();
            System.out.println(str);
        }
```



## 单例模式

### **饿汉式**

饿汉式：顾名思义，可以理解成一个饿汉，只要一加载类的时候就会创建了对象，因为用了static修饰，static修饰的成员随着类的加载而加载的

**实现步骤：1：构造函数私有化**

　　　　　**2：提供一个静态对象属性用来接收对象**

　　　　　**3：创建一个静态方法用来获取对象实例**

具体代码如下：

```java
//那么怎么让这个类在整个项目中生成一个对象呢？使用单例模式
    //单例模式第一种：饿汉式
    //弊端：占用内存，如果我不想随着类的加载而加载，想延迟加载创建对象？需要用到懒汉式
    //为什么叫饿汉式呢？一加载类的时候就创建了对象，因为用了static修饰，static修饰的成员随着类的加载而加载
    //1.第一步：构造方法需要私有化
    //2.第二步：提供一个静态对象属性用来接收对象
    //3.第三步：提供一个静态方法用来获取对象
    //随着类的加载就马上创建了对象，很饥饿
    public static Single s=new Single();
    //私有的只能在本类中使用
    private Single(){}
	//静态工厂方法
    public static Single getSingle(){
        return s;
    }
```

>   饿汉式是**线程安全**的。直接将单例对象用static修饰，把实例对象放到堆内存中，保证了多个线程在访问时的可见性。但是缺点也是很大的，正是由于把实例对象放到堆内存中，这样应用一加载就会看到对应实例，极大浪费内存。



### **懒汉式**

懒汉式：比较懒的加载，不会随着类的加载而加载，而是在你调用创建对象实例的方法时才会创建对想

实现步骤：

```
第一步：构造方法需要私有化
第二步：提供一个静态属性
第三步：提供一个方法用来创建对象
```

代码实现如 :

```java
 //懒汉式:顾名思义，这个是比较的懒的，在我们加载类的时候没有创建对象，而是在你调用了方法的时候才创建
    //第一步：构造方法需要私有化
    //第二步：提供一个静态属性
    //第三步：提供一个方法用来创建对象
    public static volatile LazySingle lazySingle;
    private LazySingle(){}
    public static LazySingle getLazySingle(){
        //这里面需要创建对象
        //怎么解决？也就是说如何避免两个不同的线程创建不同的对象？
        //判断对象是否为空，为空进去创建，不为空就不能够创建
        //需要使用同步把生成的对象的相关代码锁起来（同步代码块或者同步方法都可以）
        // synchronized(锁对象) {}  LazySingle.class字节码对象
        //LazySingle加载到内存中去会编译成LazySingle.class文件，
        // 到JVM内存中，首先会加载到方法区，
        // 方法区中可能不止一个LazySingle.class文件，可能会有Dag.class,Cat.class...
        // 这样方法区中会存在很多的字节码文件，用面向对象的思维编写它，专门用一个类称呼它Class类
        //那么每一个字节码文件可以看成是一个字节码文件对象
//        Class<LazySingle> lazySingleClass = LazySingle.class;//Class类，Class类中的 LazySingle.class对象
        //还没有很完善，因为使用同步代码块会存在开锁和关锁的一个步骤，会降低执行效率，损耗时间
        //而且不同的线程去访问它的时候都要执行同步代码块，会降低执行效率，消耗时间
        //因为使用同步代码块会降低执行效率，消耗时间，为了避免减少使用同步代码块的一个次数
        //需要判断如果对象为空的时候才进入同步代码块
        //假如没有创建对象之前，两个不同的线程同时进入，那么所创建的对象也不一样
        // 就需要用同步代码块把生成对象的相关代码锁起来
        // 锁对象使用类的字节码对象 因为使用同步代码块会消耗时间
        // 为了避免减少使用同步代码块的次数，需要判断对象为空的时候，才进入同步代码块
        //这里是进行了双重检查 两个if判断
        if(lazySingle==null) {//如果不等于就不要创建，等于null创建 有利于提升执行效率
            synchronized (LazySingle.class) {//锁对象使用字节码对象
                //如何避免两个线程创建创建不同的对象
                //判断对象是否为空
                //判断对象是否为空，为空进去创建，不为空就不能够创建
                if (lazySingle == null) {
                    lazySingle = new LazySingle();
                }
            }
        }
        return lazySingle;
    }

    public void eat(){
        System.out.println("大口吃饭");
    }
```

>   第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，**第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。**
>
>   
>
>   第二次判断是为了避免以下情况的发生。
>    (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.
>    (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。
>    (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。
>
>   另外，需要注意 `uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要。
>
>   `uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：
>
>   1.  为 `uniqueInstance` 分配内存空间
>   2.  初始化 `uniqueInstance`
>   3.  将 `uniqueInstance` 指向分配的内存地址
>
>   但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。
>
>   
>
>   **使用 `volatile` 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行**。
>
>   有一个误区：就是认为已经有Synchronized，怎么会被抢占？
>
>   但是需要注意的是，Synchronized只是为了保证同步，也就是当有多个线程对同一段程序进行操作时，能够保证只有一个线程能够获取到资源，至于是谁获取资源，可不可以抢占它不管的。
>
>   
>
>   线程安全问题：
>
>   **线程不安全**的，如果有两个线程，同一时刻拿到单例对象，要去静态工厂办法访问，由于工厂办法没有锁，那么很有可能这两个线程最终会拿到两个实例。
>
>   所以才要使用synchronized修饰，为了性能所以使用到静态代码块上，而不是方法上
>
>   但这样还是不安全的，因为会发生指令重排的问题，所以需要用volatile进行修饰。
>
>   结束
>
>   
>
>   最推荐的是使用枚举类实现单例模式，这是**线程安全**的。JVM会保证枚举类中的构造方法只调用一次，因此使用枚举会保证只实例化一次。
>
>   ```java
>   **
>    * 枚举模式：最安全
>    */
>   public class SingletonExample6 {
>   
>       // 私有构造函数
>       private SingletonExample6() {
>   
>       }
>   
>       public static SingletonExample6 getInstance() {
>           return Singleton.INSTANCE.getInstance();
>       }
>   
>       private enum Singleton {
>           INSTANCE;
>   
>           private SingletonExample6 singleton;
>   
>           // JVM保证这个方法绝对只调用一次
>           Singleton() {
>               singleton = new SingletonExample6();
>           }
>   
>           public SingletonExample6 getInstance() {
>               return singleton;
>           }
>       }
>   }
>   ```



多线程安全问题

大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。

常见的有两种解决办法：

1. 在 Bean 中尽量避免定义可变的成员变量。
2. 在类中定义一个 `ThreadLocal` 成员变量，将需要的可变成员变量保存在 `ThreadLocal` 中（推荐的一种方式）。

不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的



## 多线程

### AQS:countdownlacth

同步工具：CountDownLatch 基于AQS（num值在运行过程中无法重置。如果需要重置计数的版本，可以考虑使用CyclicBarrier）

允许一条或者多条线程等待其他线程中的一组操作完成后，再继续执行。

（eg：主线程等待子线程都执行结束，再执行相关操作） 

主线程：CountDownLatch latch = new CountDownLatch（num）；// 子线程个数

子线程：latch.countDown();

主线程：latch.await（）；//await方法使当前线程等待直到count值为0，或者当前线程被打断！如果当前的count值为0，那么aw



#### Example1

```java
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        //子线程个数
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            //此处会创建匿名了内部线程
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown(); //这个不管是否异常都需要数量减,否则会被堵塞无法结束
            });
        }
        countDownLatch.await();//保证之前的所有的线程都执行完成，才会走下面的
        System.out.println("end");
        executorService.shutdown();
    }
}
```



#### Example2

```java
import java.util.Random;
import java.util.concurrent.*;

public class DiskMemory {
    //利用countdownlaich应用场景是统计四个盘的容量大小
    private int totalSize;

    public int getSize(){
        return (new Random().nextInt(3) + 1)*100;
    }

    public void setSize(int size){
        totalSize += size;
    }

    public int getTotalSize(){
        return totalSize;
    }
}

class t3{
    public static void main(String[] args) throws InterruptedException {
        //创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        //初始化磁盘空间
        DiskMemory diskMemory = new DiskMemory();

        //创建四个线程
        CountDownLatch countDownLatch =  new CountDownLatch(4);

        //完成四个线程的获取
        for (int i = 0; i < 4; i++) {
            executorService.execute(()->{
                //重写runnable 的run方法,实现代码逻辑
                int size = diskMemory.getSize();
                diskMemory.setSize(size);
                System.out.println("线程执行，磁盘大小为："+size);
            });
            //子线程--
            countDownLatch.countDown();
        }
        
        //唤醒主线程
        countDownLatch.await();
        System.out.println("磁盘总容量为："+diskMemory.getTotalSize());
        //关闭线程池
        executorService.shutdown();
    }
}
```



### reentrantLock

```java
public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
```



## 线程创建

有三种使用线程的方法：

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。

### 实现 Runnable 接口

需要实现接口中的 run() 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
```

使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。

```java
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

### 实现 Callable 接口

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

### 继承 Thread 类

同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

### 实现接口 VS 继承 Thread

实现接口会更好一些，因为：

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。



## 线程池创建

newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### newCachedThreadPool

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：

```java
 1     /**
 2      * @ClassName: NewCachedThreadPool
 3      * @description: 创建一个可缓存的线程池  可创建线程数是无限大小的
 4      * @author: mingtian
 5      * @Date:2019/5/2 12:18
 6      **/
 7     public class NewCachedThreadPool {
 8         public static void main(String[] args) {
 9             // 可缓存线程池 Executors表示启动线程的  可创建线程数是无限大小的
10             ExecutorService executorService = Executors.newCachedThreadPool();
11             for (int i = 0; i < 10; i++) {
12                 final int temp = i;
13                 // 可执行线程  execute 启动线程
14                 executorService.execute(new Runnable() {
15                     public void run() {
16                         System.out.println(Thread.currentThread().getName() + "," + temp);
17                     }
18                 });
19             }
20             //停止线程池
21             executorService.shutdown();
22 
23         }
24     }
```

**总结**：

线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。



### **newFixedThreadPool**

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：

```java
 1 /**
 2  * @ClassName: NewFixedThreadPool
 3  * @description: 创建可固定长度的线程池
 4  * @author: mingtian
 5  * @Date:2019/5/2 12:27
 6  **/
 7 public class NewFixedThreadPool {
 8     public static void main(String[] args) {
 9         //创建可固定长度的线程池，只会创建3个线程池进行处理
10         ExecutorService executorService = Executors.newFixedThreadPool(3);
11         for (int i = 0; i < 20; i++) {
12             final int temp = i;
13             // 可执行线程  execute 启动线程
14             executorService.execute(new Runnable() {
15                 public void run() {
16                     System.out.println(Thread.currentThread().getName() + "," + temp);
17                 }
18             });
19         }
20         //停止线程池
21         executorService.shutdown();
22     }
```


定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()

总结:

因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。



### **newScheduledThreadPool**

创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：

```java
 1 /**
 2  * @ClassName: NewScheduledThreadPool
 3  * @description: 创建可定时执行的线程池 延迟多久执行线程
 4  * @author: mingtian
 5  * @Date:2019/5/2 12:35
 6  **/
 7 public class NewScheduledThreadPool {
 8     public static void main(String[] args) {
 9         //创建可定时执行的线程池
10         ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3);
11         for (int i = 0; i < 10; i++) {
12             final int temp=i;
13             //schedule 方法表示线程执行  表示延迟3秒之后 开始执行线程
14             scheduledExecutorService.schedule(new Runnable() {
15                 public void run() {
16                     System.out.println(Thread.currentThread().getName()+""+temp);
17                 }
18             }, 3, TimeUnit.SECONDS);
19         }
20         //停止线程池
21         scheduledExecutorService.shutdown();
22     }
```

### newSingleThreadExecutor

表示延迟3秒执行。

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：

```java
 1 /**
 2  * @ClassName: NewSingleThreadExecutor
 3  * @description: 单例线程池
 4  * @author: mingtian
 5  * @Date:2019/5/2 12:45
 6  **/
 7 public class NewSingleThreadExecutor {
 8     public static void main(String[] args) {
 9         //单线程
10         ExecutorService executorService = Executors.newSingleThreadExecutor();
11         for (int i = 0; i < 10; i++) {
12             final int temp = i;
13             // 可执行线程  execute 启动线程
14             executorService.execute(new Runnable() {
15                 public void run() {
16                     System.out.println(Thread.currentThread().getName() + "," + temp);
17                 }
18             });
19         }
20         //停止线程池
21         executorService.shutdown();
22     }
```





